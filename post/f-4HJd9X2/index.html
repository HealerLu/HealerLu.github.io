<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>集合 | Healer</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://HealerLu.github.io/favicon.ico?v=1600420514311">
<link rel="stylesheet" href="https://HealerLu.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="集合类体系结构

Collection集合概述和使用
概述

Collection集合是单列集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素
JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List..." />
    <meta name="keywords" content="Java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://HealerLu.github.io">
        <img src="https://HealerLu.github.io/images/avatar.png?v=1600420514311" class="site-logo">
        <h1 class="site-title">Healer</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      <strong> 岁月不堪数，故人不如初</strong>
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/HealerLu" target="_blank">Healer Lu</a> | <a class="rss" href="https://HealerLu.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">集合</h2>
            <div class="post-date">2020-09-09</div>
            
            <div class="post-content" v-pre>
              <h4 id="集合类体系结构">集合类体系结构</h4>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200902164026717.png" alt="image-20200902164026717" loading="lazy"></figure>
<h5 id="collection集合概述和使用">Collection集合概述和使用</h5>
<h6 id="概述">概述</h6>
<ul>
<li>Collection集合是单列集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素</li>
<li>JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现</li>
</ul>
<h5 id="创建collection集合的对象">创建Collection集合的对象</h5>
<ul>
<li>多态的方式</li>
<li>具体的实现类ArrayList</li>
</ul>
<blockquote>
<p><code>Collection&lt;String&gt; c = new ArrayList&lt;String &gt;();</code></p>
</blockquote>
<h5 id="collection集合常用方法">Collection集合常用方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean add(E e)</td>
<td style="text-align:center">添加元素</td>
</tr>
<tr>
<td style="text-align:center">boolean remove(Object o)</td>
<td style="text-align:center">从几何中移除指定的元素</td>
</tr>
<tr>
<td style="text-align:center">void colear()</td>
<td style="text-align:center">清空集合中的元素</td>
</tr>
<tr>
<td style="text-align:center">boolean contains(Object 0)</td>
<td style="text-align:center">判断几何中是否存在指定的元素</td>
</tr>
<tr>
<td style="text-align:center">boolean isEmpty()</td>
<td style="text-align:center">判断集合是否为空</td>
</tr>
<tr>
<td style="text-align:center">int size()</td>
<td style="text-align:center">集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody>
</table>
<h5 id="collection集合的遍历">Collection集合的遍历</h5>
<h6 id="iterator迭代器集合的专用遍历方式">Iterator：迭代器，集合的专用遍历方式</h6>
<ul>
<li>Iterator<E> iterator()：返回此几何中元素的迭代器，通过集合的iterator()方法得到</li>
<li>迭代器是通过集合的iterator()方法得到的，所以我们说他是抵赖于集合而存在的</li>
</ul>
<h6 id="iterator中常用的方法">Iterator中常用的方法</h6>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
</ul>
<pre><code class="language-java">// 创建集合对象
Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();
// 向集合里面添加元素
c.add(&quot;Demo1&quot;);
c.add(&quot;Demo2&quot;);
c.add(&quot;Demo3&quot;);
c.add(&quot;Demo4&quot;);
// 创建迭代器
Iterator&lt;String&gt; it = c.iterator();
while (it.hasNext()) {
    String s = it.next();
    System.out.println(s);
}
</code></pre>
<h5 id="list集合概述和特点">List集合概述和特点</h5>
<h6 id="list集合概述">List集合概述</h6>
<ul>
<li>有序集合（也成为序列），用户可以景区控制列表中每个元素的插入位置，可以通过整数索引访问元素并搜索列表中的元素</li>
<li>与Set集合不同，列表通常允许重复的元素</li>
</ul>
<h6 id="list集合特点">List集合特点</h6>
<ul>
<li>
<p>有序：存储和取出的元素顺序一致</p>
</li>
<li>
<p>可重复：存储的元素可以重复</p>
<pre><code class="language-java">List&lt;String&gt; l = new ArrayList&lt;String&gt;();

l.add(&quot;1&quot;);
l.add(&quot;2&quot;);
l.add(&quot;3&quot;);
l.add(&quot;3&quot;);

//System.out.println(l); [1, 2, 3, 3]
// 迭代器方式遍历
Iterator&lt;String&gt; iterator = l.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
    System.out.println(s);
}
</code></pre>
</li>
</ul>
<h6 id="list集合的特有方法">List集合的特有方法</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void add(int index, E element)</td>
<td style="text-align:center">在此几何中的指定位置插入指定的元素</td>
</tr>
<tr>
<td style="text-align:center">E remove(int index)</td>
<td style="text-align:center">删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td style="text-align:center">E set(int index, E element)</td>
<td style="text-align:center">修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td style="text-align:center">E get(int index)</td>
<td style="text-align:center">返回指定索引处的元素</td>
</tr>
</tbody>
</table>
<h6 id="listiterator">ListIterator</h6>
<blockquote>
<p>ListIterator：列表迭代器</p>
</blockquote>
<ul>
<li>通过List集合的listiterator()方法得到，所以说它是List集合特有的迭代器</li>
<li>用于允许程序沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。</li>
</ul>
<blockquote>
<p>常用方法</p>
</blockquote>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
<li>E previous()：返回列表重的上一个元素</li>
<li>boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true</li>
<li>void add(E e)：将指定的元素插入列表</li>
</ul>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();

list.add(&quot;1&quot;);
list.add(&quot;2&quot;);
list.add(&quot;3&quot;);
// 正向遍历
ListIterator&lt;String&gt; iterator = list.listIterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
// 逆向遍历
while (iterator.hasPrevious()) {
    System.out.println(iterator.previous());
}
// 添加
while (iterator.hasNext()) {
    String s = iterator.next();
    if (s.equals(&quot;1&quot;)) {
        iterator.add(&quot;4&quot;);
    }
}
System.out.println(list);
</code></pre>
<h6 id="增强for循环">增强for循环</h6>
<blockquote>
<p>简化数组和Collection集合的遍历</p>
</blockquote>
<ul>
<li>实现Iterable接口的类允许其对象成为增强型for语句的目标</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li>
</ul>
<blockquote>
<p>增强for的格式</p>
</blockquote>
<pre><code class="language-java">for(元素数据类型 变量名:数组或者Collection集合){
    // 在此处使用变量即可，该变量就是元素
}
</code></pre>
<blockquote>
<p>范例</p>
</blockquote>
<pre><code class="language-java">int[] arr = {1, 2, 3, 4, 5};
for(int i : arr){
    System.out.println(i);
}
</code></pre>
<h6 id="list集合子类特点">List集合子类特点</h6>
<blockquote>
<p>list集合常用子类：ArrayList、LinkedList</p>
</blockquote>
<ul>
<li>ArrayList：底层数据结构是数组，查询快，增删慢</li>
<li>LinkedList：底层数据结构是链表，查询慢，增删快</li>
</ul>
<h6 id="linkedlist集合的特有功能">LinkedList集合的特有功能</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void addFirst(E e)</td>
<td style="text-align:center">在该列表开头插入指定的元素</td>
</tr>
<tr>
<td style="text-align:center">public void addLast(E e)</td>
<td style="text-align:center">将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td style="text-align:center">public void getFirst()</td>
<td style="text-align:center">返回此列表中的第一个元素</td>
</tr>
<tr>
<td style="text-align:center">public getLast()</td>
<td style="text-align:center">返回此列表重的最后一个元素</td>
</tr>
<tr>
<td style="text-align:center">public E removeFirst()</td>
<td style="text-align:center">从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td style="text-align:center">public E removeLast()</td>
<td style="text-align:center">从此列表中删除并返回最后一个元素</td>
</tr>
</tbody>
</table>
<h5 id="set集合">Set集合</h5>
<h6 id="set集合概述和特点">Set集合概述和特点</h6>
<ul>
<li>不包含重复元素的集合</li>
<li>没有带索引的方法，所以不能使用普通的for循环</li>
</ul>
<pre><code class="language-java">// 创建HashSet并遍历
Set&lt;Integer&gt; set = new HashSet&lt;&gt;();

set.add(1);
set.add(2);
set.add(3);

Iterator&lt;Integer&gt; it = set.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
System.out.println(set);
</code></pre>
<h6 id="哈希值">哈希值</h6>
<blockquote>
<p>哈希值是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
<p>Object类中的<code>public int hashCode()</code>方法可以返回对象的哈希码值</p>
</blockquote>
<blockquote>
<p>对象的哈希值特点</p>
</blockquote>
<ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li>
</ul>
<h6 id="linkedhashset集合的概述和特点">LinkedHashSet集合的概述和特点</h6>
<ul>
<li>hash表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h6 id="treeset集合概述和特点">TreeSet集合概述和特点</h6>
<ul>
<li>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法。
<ul>
<li>TreeSet()：根据元素的自然排序进行排序。</li>
<li>TreeSet(Comparator comparator)：根据指定的比较器进行排序。</li>
</ul>
</li>
<li>没有带索引的方法，所以不能使用普通for循环遍历</li>
<li>由于是Set集合，所以不包含重复元素</li>
</ul>
<h6 id="自然排序comparable的使用">自然排序Comparable的使用</h6>
<ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(To)方法</li>
</ul>
<h6 id="比较器排序comparator的使用">比较器排序Comparator的使用</h6>
<ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序就是让集合构造方法接收Comparator的实现类对象，重写compareTo(To1, To2)方法</li>
</ul>
<h4 id="泛型">泛型</h4>
<h5 id="泛型概述">泛型概述</h5>
<blockquote>
<p>泛型：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型<br>
它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方<br>
法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具<br>
体的类型参数化，然后在使用/调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称<br>
为泛型类、泛型方法、泛型接口</p>
</blockquote>
<h5 id="泛型定义格式">泛型定义格式</h5>
<ul>
<li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参</li>
<li>&lt;类型1，类型2...&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</li>
<li>将来具体调用的时候给定的类型可以看成是实参，并且实参的类型行只能是引用数据类型</li>
</ul>
<h5 id="泛型的好处">泛型的好处</h5>
<ul>
<li>把运行时期的问题提前到了编译期间</li>
<li>避免了强制类型转换</li>
</ul>
<h5 id="泛型类">泛型类</h5>
<h6 id="泛型类的定义格式">泛型类的定义格式</h6>
<ul>
<li>修饰符 class 类名 &lt;类型&gt; {}</li>
</ul>
<pre><code class="language-java">public class Demo&lt;T&gt;{
    // 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
}
</code></pre>
<h5 id="泛型方法">泛型方法</h5>
<h6 id="泛型方法的定义格式">泛型方法的定义格式</h6>
<ul>
<li>修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名){}</li>
</ul>
<pre><code class="language-java">public &lt;T&gt; void show(T t){}
</code></pre>
<pre><code class="language-java">// 类
public class Generic{
    // 定义泛型方法
    public &lt;T&gt; void show(T t){
        System.out.println(t);
    }
}
// 使用
public static void main(String[] args) {
    Generic g = new Generic();
    g.show(30);
    g.show(&quot;张三&quot;);
}
</code></pre>
<h5 id="泛型接口">泛型接口</h5>
<h6 id="泛型接口的定义格式">泛型接口的定义格式</h6>
<ul>
<li>修饰符 interface 接口名 &lt;类型&gt; {}</li>
</ul>
<pre><code class="language-java">public interface Generic&lt;T&gt;{}
</code></pre>
<h5 id="类型通配符">类型通配符</h5>
<h6 id="类型通配符概述">类型通配符概述</h6>
<ul>
<li>为了表示各种泛型List的父类。可以使用类型通配符</li>
<li>类型通配符：&lt;?&gt;</li>
<li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型</li>
<li>这种代通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li>
</ul>
<blockquote>
<p>如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
</blockquote>
<ul>
<li>
<p>类型通配符上限：&lt;? extends 类型&gt;</p>
</li>
<li>
<pre><code class="language-java">List&lt;? extends Number&gt; //表示的类型是Number或者其子类型
</code></pre>
</li>
</ul>
<blockquote>
<p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p>
</blockquote>
<ul>
<li>
<p>类型通配符下限：&lt;? super 类型&gt;</p>
</li>
<li>
<pre><code class="language-java">List&lt;? super Number&gt; //表示的类型是Number或者其父类型
</code></pre>
</li>
</ul>
<h5 id="可变参数">可变参数</h5>
<h6 id="可变参数概述">可变参数概述</h6>
<ul>
<li>
<p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数的格式就是可变的了</p>
</li>
<li>
<p>格式：修饰符 返回值类型 方法名(数据类型... 变量名){}</p>
</li>
<li>
<pre><code class="language-java">public static int sun(int... a){}
</code></pre>
</li>
</ul>
<h6 id="可变参数的使用">可变参数的使用</h6>
<blockquote>
<p>Arrays工具类中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <T> List<T> asList(T... a)：返回由指定数组支持的固定大小的列表</li>
<li>返回的集合不能做增删操作，可以做修改操作</li>
</ul>
<blockquote>
<p>List接口中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <E> List <E> of (E... elements)：返回包含任意数量元素的不可变列表</li>
<li>返回的集合不能做增删改操作</li>
</ul>
<blockquote>
<p>Set接口中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <E> Set <E> of (E... element)：返回一个包含任意数量元素的不可变集合</li>
<li>返回的集合不能做增删操作，没有修改的方法</li>
<li>再给元素的时候，不能给重复的元素</li>
</ul>
<h4 id="map集合">Map集合</h4>
<h5 id="map集合的概述和使用">Map集合的概述和使用</h5>
<ul>
<li>Interface Map&lt;K,V&gt;      K：键的类型      V：值的类型</li>
<li>将键映射到值得对象，不能包含重复的键，每个键可以映射到最多一个值</li>
</ul>
<h5 id="创建map集合的对象">创建Map集合的对象</h5>
<ul>
<li>多态的方式</li>
<li>具体的实现类HashMap</li>
</ul>
<h5 id="map集合的基本功能">Map集合的基本功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V put(K key, V value)</td>
<td style="text-align:center">添加元素</td>
</tr>
<tr>
<td style="text-align:center">V remove(Object key)</td>
<td style="text-align:center">根据键删除键值对元素</td>
</tr>
<tr>
<td style="text-align:center">void clear()</td>
<td style="text-align:center">移除所有的键值对元素</td>
</tr>
<tr>
<td style="text-align:center">boolean containsKey(Object key)</td>
<td style="text-align:center">判断集合是否包含制定的键</td>
</tr>
<tr>
<td style="text-align:center">boolean containsValue(Object value)</td>
<td style="text-align:center">判断集合是否包含指定的值</td>
</tr>
<tr>
<td style="text-align:center">boolean isEmpty()</td>
<td style="text-align:center">判断集合是否为空</td>
</tr>
<tr>
<td style="text-align:center">int size()</td>
<td style="text-align:center">集合的长度，也就是几何中键值对的个数</td>
</tr>
</tbody>
</table>
<h5 id="map集合的获取功能">Map集合的获取功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V get(Object key)</td>
<td style="text-align:center">根据键获取值</td>
</tr>
<tr>
<td style="text-align:center">Set<K> keySet()</td>
<td style="text-align:center">获取所有键的集合</td>
</tr>
<tr>
<td style="text-align:center">Collection<V> values()</td>
<td style="text-align:center">获取所有值的集合</td>
</tr>
<tr>
<td style="text-align:center">Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet</td>
<td style="text-align:center">获取所有键值对对象的集合</td>
</tr>
</tbody>
</table>
<h5 id="map的遍历">Map的遍历</h5>
<h6 id="方法一">方法一：</h6>
<pre><code class="language-java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

map.put(&quot;张三&quot;, &quot;20岁&quot;);
map.put(&quot;李四&quot;, &quot;30岁&quot;);
map.put(&quot;王五&quot;, &quot;40岁&quot;);
// 获取键
Set&lt;String&gt; keySet = map.keySet();

for(String key : keySet) {
    // 根据键获取值
    String value = map.get(key);
    System.out.println(key + &quot;,&quot; + value);
    /*李四,30岁
            张三,20岁
            王五,40岁*/
}
</code></pre>
<h6 id="方法二">方法二：</h6>
<pre><code class="language-java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

map.put(&quot;张三&quot;, &quot;20岁&quot;);
map.put(&quot;李四&quot;, &quot;30岁&quot;);
map.put(&quot;王五&quot;, &quot;40岁&quot;);
// 获取所有键值对
Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();

for (Map.Entry&lt;String, String&gt; me : entrySet) {
    // 获取键
    String key = me.getKey();
    // 获取值
    String value = me.getValue();
    System.out.println(key + &quot;，&quot; + value);
}
</code></pre>
<h5 id="集合嵌套之arraylist嵌套hashmap">集合嵌套之ArrayList嵌套HashMap</h5>
<pre><code class="language-java">// 创建ArrayList集合
ArrayList&lt;HashMap&lt;String, String&gt;&gt; array = new ArrayList&lt;&gt;();
// 创建HashMap集合
HashMap&lt;String, String&gt; hm1 = new HashMap&lt;&gt;();
// 将键值对添加到HashMap
hm1.put(&quot;张三&quot;, &quot;20&quot;);
// 将HashMap添加到ArrayList集合
array.add(hm1);

HashMap&lt;String, String&gt; hm2 = new HashMap&lt;&gt;();
hm2.put(&quot;李四&quot;, &quot;30&quot;);
array.add(hm2);

HashMap&lt;String, String&gt; hm3 = new HashMap&lt;&gt;();
hm3.put(&quot;王五&quot;, &quot;40&quot;);
array.add(hm3);

// 遍历ArrayList集合
for (HashMap&lt;String, String&gt; hm : array) {
    // 获取HashMap的键
    Set&lt;String&gt; keySet = hm.keySet();
    for (String key : keySet) {
        // 根据键获取值
        String value = hm.get(key);
        // 循环输出
        System.out.println(key + &quot;---&quot; + value);
    }
}
</code></pre>
<h4 id="collections">Collections</h4>
<h5 id="collections类的概述">Collections类的概述</h5>
<ul>
<li>是针对集合操作的工具类</li>
</ul>
<h5 id="collections类的常用方法">Collections类的常用方法</h5>
<ul>
<li><code>public static &lt;T ectends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>：将制定的列表按升序排序</li>
<li><code>public static void reverse(List&lt;?&gt; list)</code>：反转指定列表中元素的顺序</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>：使用默认的随机源随机排列指定的列表</li>
</ul>
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

list.add(10);
list.add(50);
list.add(40);
list.add(20);

// Collections.sort(list);    // 排序
// Collections.reverse(list); // 反转
// Collections.shuffle(list); // 随机置换

System.out.println(list);
</code></pre>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://HealerLu.github.io/tag/Vk-b-Atmn/" class="tag">
                    Java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://HealerLu.github.io/post/8rKXVY6sg/">
                  <h3 class="post-title">
                    多态
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
