<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>IO | Healer</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://HealerLu.github.io/favicon.ico?v=1600408791154">
<link rel="stylesheet" href="https://HealerLu.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="File
File类概述

File是文件和目录路径名的抽象表示


文件和目录是可以通过File封装成对象的
对于File而言。其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操..." />
    <meta name="keywords" content="Java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://HealerLu.github.io">
        <img src="https://HealerLu.github.io/images/avatar.png?v=1600408791154" class="site-logo">
        <h1 class="site-title">Healer</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      <strong> 岁月不堪数，故人不如初</strong>
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/HealerLu" target="_blank">Healer Lu</a> | <a class="rss" href="https://HealerLu.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">IO</h2>
            <div class="post-date">2020-09-11</div>
            
            <div class="post-content" v-pre>
              <h3 id="file">File</h3>
<h4 id="file类概述">File类概述</h4>
<blockquote>
<p>File是文件和目录路径名的抽象表示</p>
</blockquote>
<ul>
<li>文件和目录是可以通过File封装成对象的</li>
<li>对于File而言。其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转为具体存在的。</li>
</ul>
<h4 id="file类的构造方法">File类的构造方法</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">File(String pathname)</td>
<td style="text-align:center">通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td style="text-align:center">File(String parent, String child)</td>
<td style="text-align:center">从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td style="text-align:center">File(File parent, String child)</td>
<td style="text-align:center">从父抽象路径名和自路径名字符串创建新的File实例</td>
</tr>
</tbody>
</table>
<h4 id="file类创建功能">File类创建功能</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean createNewFile()</td>
<td style="text-align:center">当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td>
</tr>
<tr>
<td style="text-align:center">public boolean mkdir()</td>
<td style="text-align:center">创建由此抽象路径命名的目录</td>
</tr>
<tr>
<td style="text-align:center">public boolean mkdirs()</td>
<td style="text-align:center">创建由此抽象路径命名的目录，包括任何必须但不存在的父目录</td>
</tr>
</tbody>
</table>
<h5 id="file类的判断和获取功能">File类的判断和获取功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean isDirectory()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否为目录</td>
</tr>
<tr>
<td style="text-align:center">public boolean isFile()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td style="text-align:center">public boolean exists()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td style="text-align:center">public String getAbsoultePath()</td>
<td style="text-align:center">返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td style="text-align:center">public String getPath()</td>
<td style="text-align:center">将此抽象路径转换为路径名字符串</td>
</tr>
<tr>
<td style="text-align:center">public String getName()</td>
<td style="text-align:center">返回此抽线路径名表示的文件或目录的名称</td>
</tr>
<tr>
<td style="text-align:center">public String[] list()</td>
<td style="text-align:center">返回此抽象路径名标识的目录中的文件和目录的名称字符串数组</td>
</tr>
<tr>
<td style="text-align:center">public File[] listFiles()</td>
<td style="text-align:center">返回此抽象路径名表示的目录中的文件和目录的File对象数组</td>
</tr>
</tbody>
</table>
<h5 id="file类的删除功能">File类的删除功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean delete()</td>
<td style="text-align:center">删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody>
</table>
<h3 id="字节流">字节流</h3>
<h4 id="io流概述和分类">IO流概述和分类</h4>
<h5 id="io流概述">IO流概述</h5>
<ul>
<li>IO：输入/输出(input/Output)</li>
<li>流：是一种抽象概念，是对数据传输的总成。也就是说数据在设备间的传输称为流，流的本质是数据传输。</li>
<li>IO流就是用来处理设备间数据传输问题的，常见的应用：我呢见赋值、文件上传、文件下载</li>
</ul>
<h5 id="分类">分类</h5>
<ul>
<li>
<p>按照数据的流向</p>
<ul>
<li>输入流：读数据</li>
<li>输出流：写数据</li>
</ul>
</li>
<li>
<p>按照数据类型分类</p>
<ul>
<li>字节流
<ul>
<li>字节输入流、字节输出流</li>
</ul>
</li>
<li>字符流
<ul>
<li>字符输入流、字符输出流</li>
</ul>
</li>
</ul>
<blockquote>
<p>一般来说是按照数据类型来分的</p>
</blockquote>
</li>
</ul>
<h5 id="字节流写数据">字节流写数据</h5>
<h6 id="字节流抽象基类">字节流抽象基类</h6>
<ul>
<li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li>
<li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li>
</ul>
<h6 id="fileoutputstream文件输出流用于将数据写入file">FileOutputStream：文件输出流用于将数据写入file</h6>
<ul>
<li>FileOutputStream(String name)：创建文件输出流以指定的名称写入文件</li>
</ul>
<h6 id="使用字节输出流写数据的步骤">使用字节输出流写数据的步骤：</h6>
<ul>
<li>创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）</li>
<li>调用字节输出流对象的写数据方法</li>
<li>释放资源（关闭此文件输出流并释放与此流相关联的任何系统资源）</li>
</ul>
<h6 id="字节流写数据的方法">字节流写数据的方法</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void write(int b)</td>
<td style="text-align:center">将指定的字节写入此文件输出流<br />一次写一个字节数据</td>
</tr>
<tr>
<td style="text-align:center">void write(byte[] b)</td>
<td style="text-align:center">将b.lenght字节从指定得字节数组写入此文件输出流<br />一次写一个字节的数据</td>
</tr>
<tr>
<td style="text-align:center">void write(byte[] b, int off, int len)</td>
<td style="text-align:center">将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流<br />一次写一个字节数组的部分数据</td>
</tr>
</tbody>
</table>
<h6 id="字节流写数据实现换行">字节流写数据实现换行</h6>
<pre><code class="language-java">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);

for (int i = 0; i &lt; 10; i ++) {
    fos.write(&quot;hello&quot;.getBytes());
    // 实现换行   windows：\r\n   linux：\n mac: \r
    fos.write(&quot;\r\n&quot;.getBytes());
}
// 释放资源
fos.close();
</code></pre>
<h6 id="字节流写数据实现追加写入">字节流写数据实现追加写入</h6>
<ul>
<li>public FileOutputStream(String name, boolean append)</li>
<li>创建文件输出流以指定的名称写入文件，如果第二个参数为true，则字节将写入文件的末尾而不是开头</li>
</ul>
<h6 id="字节流写数据加异常处理">字节流写数据加异常处理</h6>
<ul>
<li>finally：在异常处理时提供finally块来执行所有清除操作。比如IO流中的释放资源</li>
<li>特点：被finally控制的语句一定会执行，除非JVM退出</li>
</ul>
<pre><code class="language-java">try{
    // 可能出现异常的代码
}catch(异常类名 变量名) {
    // 异常的处理代码
} finally{
    // 执行所有的清楚操作
}
</code></pre>
<pre><code class="language-java">FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(&quot;Z:\\test&quot;);
            fos.write(&quot;Hello&quot;.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
</code></pre>
<h5 id="字节缓冲流">字节缓冲流</h5>
<ul>
<li>BufferedOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</li>
<li>BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从包含的输入流中重新填充，一次很多字节</li>
</ul>
<h6 id="构造方法">构造方法</h6>
<ul>
<li>字节缓冲输出流：BufferedOutputStream(OutputStream out)</li>
<li>字节缓冲输入流：BufferedInputStream(InputStream in)</li>
<li>构造方法需要的是字节流而不是具体的文件或者路径，是因为字节缓冲流仅仅提供缓冲区域，而真正读写数据还得依靠基本的字节流对象进行操作</li>
</ul>
<h3 id="字符流">字符流</h3>
<h4 id="为什么会出现字符流">为什么会出现字符流</h4>
<blockquote>
<p>由于字节流操作中文不是特别的方便，所以Java就提供了字符流</p>
</blockquote>
<ul>
<li>字符流 = 字节流 + 编码表</li>
</ul>
<h4 id="字符串中的编码解码问题">字符串中的编码解码问题</h4>
<h5 id="相关方法">相关方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte[] getBytes()</td>
<td style="text-align:center">使用平台的默认字符集将该 String编码为一系列字节</td>
</tr>
<tr>
<td style="text-align:center">byte[] getBytes(String charsetName)</td>
<td style="text-align:center">使用指定的字符集将该 String编码为一系列字节</td>
</tr>
<tr>
<td style="text-align:center">String(byte[] bytes)</td>
<td style="text-align:center">使用平台的默认字符集解码指定的字节数组来创建字符串</td>
</tr>
<tr>
<td style="text-align:center">String(byte[] bytes, String charsetName)</td>
<td style="text-align:center">通过指定的字符集解码指定的字节数组来创建字符串</td>
</tr>
</tbody>
</table>
<h4 id="字符流中的编码解码问题">字符流中的编码解码问题</h4>
<h5 id="字符流抽象基类">字符流抽象基类</h5>
<ul>
<li>Reader：字符输入流的抽象类</li>
<li>Writer：字符输出流的抽象类</li>
</ul>
<h5 id="字符流中和编码解码问题相关的两个类">字符流中和编码解码问题相关的两个类</h5>
<ul>
<li>InputStreamReader     字符输入流</li>
<li>OutputStreamWriter    字符输出流</li>
</ul>
<h5 id="便捷转换类">便捷转换类</h5>
<ul>
<li>FileReader：用于读取字符文件的便捷类
<ul>
<li>File Reader(String fileName)</li>
</ul>
</li>
<li>FileWriter：用于写入字符文件的便捷类
<ul>
<li>FileWriter(String fileName)</li>
</ul>
</li>
</ul>
<h4 id="字符流写数据的5种方式">字符流写数据的5种方式</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void write(int c)</td>
<td style="text-align:center">写一个字符</td>
</tr>
<tr>
<td style="text-align:center">void write(char[] cbuf)</td>
<td style="text-align:center">写入一个字符数组</td>
</tr>
<tr>
<td style="text-align:center">void write(char[] cbuf, int off, int len)</td>
<td style="text-align:center">写入字符数组的一部分</td>
</tr>
<tr>
<td style="text-align:center">void write(String str)</td>
<td style="text-align:center">写一个字符串</td>
</tr>
<tr>
<td style="text-align:center">void write(String str, int off, int len)</td>
<td style="text-align:center">写一个字符串的一部分</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flush()</td>
<td style="text-align:center">刷新流，还可以继续写数据</td>
</tr>
<tr>
<td style="text-align:center">close()</td>
<td style="text-align:center">关闭流，释放资源，但是在关闭前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody>
</table>
<h4 id="字符流读数据的2种方式">字符流读数据的2种方式</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int read()</td>
<td style="text-align:center">一次读一个字符数据</td>
</tr>
<tr>
<td style="text-align:center">int read(char[] cbuf)</td>
<td style="text-align:center">一次读一个字符数组数据</td>
</tr>
</tbody>
</table>
<h4 id="字符缓冲流">字符缓冲流</h4>
<h5 id="字符缓冲流-2">字符缓冲流</h5>
<ul>
<li>BufferedWriter ：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可<br>
以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</li>
<li>BufferedReader ：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓<br>
冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途</li>
</ul>
<h5 id="构造方法-2">构造方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedWriter(Writer out)</td>
<td style="text-align:center">创建字符缓冲输出流对象</td>
</tr>
<tr>
<td style="text-align:center">BufferedReader(Reader in)</td>
<td style="text-align:center">创建字符缓冲输入流对象</td>
</tr>
</tbody>
</table>
<h4 id="字符缓冲流的特有功能">字符缓冲流的特有功能</h4>
<ul>
<li>BufferedWriter
<ul>
<li>void newLine()：写一行行分隔符，行分隔符字符串由系统属性定义</li>
</ul>
</li>
<li>BufferedReader:
<ul>
<li>public String readLine()：读一行文字。结果包含行的内容字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null</li>
</ul>
</li>
</ul>
<h3 id="io流小结">IO流小结</h3>
<h5 id="字节流-2">字节流</h5>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200911154542655.png" alt="image-20200911154542655" loading="lazy"></figure>
<h5 id="字符流-2">字符流</h5>
<figure data-type="image" tabindex="2"><img src="https://HealerLu.github.io/post-images/image-20200911154617711.png" alt="image-20200911154617711" loading="lazy"></figure>
<h4 id="复制多级文件案例">复制多级文件案例</h4>
<pre><code class="language-java">public class CopyFolder {
    public static void main(String[] args) throws IOException {
        // 创建数据源File对象
        File srcFile = new File(&quot;数据源路径&quot;);
        // 创建目的地File对象
        File destFile = new File(&quot;目的地路径&quot;);

        copyFolder(srcFile, destFile);

    }
    // 文件夹的复制方法
    public static void copyFolder(File srcFile, File destFile) throws IOException {
        if (srcFile.isDirectory()) {
            String srcFileName = srcFile.getName();
            // 生成新的目录
            File newFolder = new File(destFile, srcFileName);
            if (!newFolder.exists()) {
                newFolder.mkdir();
            }
            // 获取数据源目录下的所有文件或者文件夹的数组
            File[] fileArray = srcFile.listFiles();
            // 遍历数组得到每一个File对象
            for(File file : fileArray) {
                // 把该file作为数据源File对象，递归调用复制文件夹的方法
                copyFolder(file, newFolder);
            }
        } else {
            // 说明是文件，直接复制
            File newFile = new File(destFile, srcFile.getName());
            copyFile(srcFile, newFile);
        }
    }
    // 字节流缓冲复制文件  try ... catch ... finally的方式处理异常
    /*public static void copyFile(File srcFile, File destFile) {
        BufferedInputStream bf = null;
        BufferedOutputStream bo = null;
        try {
            // 字节流缓冲输入方法
            bf = new BufferedInputStream(new FileInputStream(srcFile));
            // 字节流缓冲输出方法
            bo = new BufferedOutputStream(new FileOutputStream(destFile));

            byte[] bys = new byte[1024];
            int len;
            while ((len = bf.read(bys)) != -1) {
                bo.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (bf != null) {
                try {
                    bf.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (bo != null) {
                try {
                    bo.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }*/
    // JDK7之后的改进方案，可以自动释放资源
    /*public static void copyFile(File srcFile, File destFile) {
        try(BufferedInputStream bf = new BufferedInputStream(new FileInputStream(srcFile));
            BufferedOutputStream bo = new BufferedOutputStream(new FileOutputStream(destFile));) {

            byte[] bys = new byte[1024];
            int len;
            while ((len = bf.read(bys)) != -1) {
                bo.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }*/
    // JDK9之后的改进方案
    public static void copyFile(File srcFile, File destFile) throws IOException {
        BufferedInputStream bf = new BufferedInputStream(new FileInputStream(srcFile));
        BufferedOutputStream bo = new BufferedOutputStream(new FileOutputStream(destFile));
        try(bf; bo) {
            byte[] bys = new byte[1024];
            int len;
            while ((len = bf.read(bys)) != -1) {
                bo.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}

</code></pre>
<h3 id="特殊操作流">特殊操作流</h3>
<h4 id="标准输入输出流">标准输入输出流</h4>
<h5 id="标准输入流">标准输入流</h5>
<blockquote>
<p>System类中有两个静态的成员变量：</p>
</blockquote>
<ul>
<li>public static final InputStream in：标准输入流。通常该流对应于键盘输入活由主机环境或用户指定的另一个输入源。</li>
<li>public static final printStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标。</li>
</ul>
<blockquote>
<p>自己实现键盘录入数据：</p>
</blockquote>
<ul>
<li>
<pre><code class="language-java">BufferedReader brs = new BufferedReader(new InputStreamReader(System.in));
</code></pre>
</li>
</ul>
<blockquote>
<p>Java也直接提供了一个类实现键盘录入</p>
</blockquote>
<ul>
<li>
<pre><code class="language-java">Scanner sc = new Scanner(System.in);
</code></pre>
</li>
</ul>
<h5 id="标准输出流">标准输出流</h5>
<blockquote>
<p>输出语句的本质是一个标准输出流</p>
</blockquote>
<ul>
<li>printStream ps = System.out;</li>
<li>printStream类有的方法，System.out都可以使用</li>
</ul>
<h4 id="打印流">打印流</h4>
<h5 id="打印流分类">打印流分类：</h5>
<ul>
<li>字节打印流：PrintSteam</li>
<li>字符打印流：PrintWrite</li>
</ul>
<h5 id="打印流的特点">打印流的特点：</h5>
<ul>
<li>只负责输出数据，不负责读取数据</li>
<li>有自己的特有方法</li>
</ul>
<h5 id="字节打印流">字节打印流</h5>
<ul>
<li>PrintStream(String fileName)：使用指定的文件名创建新的打印流</li>
<li>使用继承父类的方法写数据，查看的时候会转码；使用自己特有的方法写出局，查看的数据原样输出</li>
</ul>
<h5 id="字符打印流">字符打印流</h5>
<blockquote>
<p>字符打印流PrintWriter的构造方法</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PrintWriter(String fileName)</td>
<td style="text-align:left">使用指定文件创建一个新的PrintWriter，而不需要自动执行刷新</td>
</tr>
<tr>
<td style="text-align:left">PrintWriter(Writer out, boolean autoFlush)</td>
<td style="text-align:left">创建一个新的PrinWriter<br />- out:字符输出流<br />- autoFlush：一个布尔值，如果为真，则printIn、printf或format方法将刷新输出缓冲区</td>
</tr>
</tbody>
</table>
<h4 id="对象序列化流">对象序列化流</h4>
<blockquote>
<p>对象序列化：就是将对象保存到磁盘中，或者在网络中串数对象</p>
<p>这种机制就是使用了一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象存储的属性等信息。字节序列写到文件之后，相当于文件中持久保存了一个对象的信息</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对他进行反序列化</p>
</blockquote>
<h5 id="对象序列化流和对象饭序列化流">对象序列化流和对象饭序列化流</h5>
<ul>
<li>对象序列化流：ObjectOutputStream</li>
<li>对象反序列化流：ObjectInputStream</li>
</ul>
<h6 id="对象序列化流-2">对象序列化流</h6>
<blockquote>
<p>ObjectOutputStream：将Java对象的原始数据类型和图形写入OutputStream，可以使用ObjectInputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以再另一个主机上或另一个进程中重构对象</p>
</blockquote>
<ul>
<li>构造方法
<ul>
<li>ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream</li>
</ul>
</li>
<li>序列化对象方法
<ul>
<li>void writeObject(Object obj)：将指定的对象写入ObjectOutputStream</li>
</ul>
</li>
</ul>
<blockquote>
<p>一个对象想要被序列化，该对象所属的类必须实现Serializable接口</p>
<p>Serializable是一个标记接口，实现该接口，不需要重写任何方法</p>
</blockquote>
<ul>
<li>
<p>注意事项</p>
<ul>
<li>
<p>用对象序列化流序列化了一个对象后，修改对象所属的类文件后，出现了InvalidClassException</p>
<ul>
<li>
<p>给对象所属的类加一个serialVersionUID</p>
<ul>
<li>
<pre><code class="language-java">private static final long serialVersionUID = 42L
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对象中的某个成员变量的值不想被序列化时，可以给成员变量添加<code>transient</code>关键字修饰，该关键字标记的成员变量不参与序列化过程</p>
</li>
</ul>
</li>
</ul>
<h6 id="对象反序列化流">对象反序列化流</h6>
<blockquote>
<p>ObjectInputStream：反序列化先前使用ObjectOutputStream编写的原始数据和对象</p>
</blockquote>
<ul>
<li>构造方法
<ul>
<li>ObjectInputStream(inputStream in)：创建从指定得InputStream读取的ObjectInputStream</li>
</ul>
</li>
<li>反序列化对象方法
<ul>
<li>ObjectreadObject()：从ObjectInputStream读取一个对象</li>
</ul>
</li>
</ul>
<h3 id="properties">Properties</h3>
<h4 id="properties概述">Properties概述</h4>
<ul>
<li>是一个Map体系的集合类</li>
<li>Properties可以保存到流中或从流中加载</li>
</ul>
<h4 id="properties作为集合特有的方法">Properties作为集合特有的方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object setProperty(String key, String value)</td>
<td>设置集合的键和值，都是String类型，底层调用Hashtable方法 put</td>
</tr>
<tr>
<td>String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性</td>
</tr>
<tr>
<td>Set<String> stringPropertyNames()</td>
<td>从该属性列表重返回一个不可修改的键集，其中键及其对应的值是字符串</td>
</tr>
</tbody>
</table>
<h4 id="properties和io流结合的方法">Properties和IO流结合的方法：</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void load(InputStream inStream)</td>
<td>从输入字节流读取属性列表（键和元素对）</td>
</tr>
<tr>
<td>void load(Reader reader)</td>
<td>从输入字符流读取属性列表（键和元素对）</td>
</tr>
<tr>
<td>void store(OutputStream out, String comments)</td>
<td>将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(inputStream)方法的格式写入输出字节流</td>
</tr>
<tr>
<td>void store(Writer writer, String comments)</td>
<td>将此属性列表（键和元素对）写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流</td>
</tr>
</tbody>
</table>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://HealerLu.github.io/tag/Vk-b-Atmn/" class="tag">
                    Java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://HealerLu.github.io/post/f-4HJd9X2/">
                  <h3 class="post-title">
                    集合
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
