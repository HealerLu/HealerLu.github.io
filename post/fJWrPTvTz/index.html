<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8" >

<title>网络编程 | Healer</title>

<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">

<link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.7.2/css/all.css" integrity="sha384-fnmOCqbTlWIlj8LyTjo7mOUStjsKC4pOpQbqyi7RrhN7udi9RwhKkMHpvLbHG9Sr" crossorigin="anonymous">
<link rel="shortcut icon" href="https://HealerLu.github.io/favicon.ico?v=1600846900571">
<link rel="stylesheet" href="https://HealerLu.github.io/styles/main.css">



<link rel="stylesheet" href="https://unpkg.com/aos@next/dist/aos.css" />
<script src="https://cdn.jsdelivr.net/npm/vue/dist/vue.js"></script>



    <meta name="description" content="网络编程
网络编程概述
计算机网络

是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来；在网络操作系统，网络管理软件及网络通讯协议的管理和协调下，实现资源共享和信息传递的计算机系统。

网络编程

在网络通信协..." />
    <meta name="keywords" content="Java" />
  </head>
  <body>
    <div id="app" class="main">

      <div class="sidebar" :class="{ 'full-height': menuVisible }">
  <div class="top-container" data-aos="fade-right">
    <div class="top-header-container">
      <a class="site-title-container" href="https://HealerLu.github.io">
        <img src="https://HealerLu.github.io/images/avatar.png?v=1600846900571" class="site-logo">
        <h1 class="site-title">Healer</h1>
      </a>
      <div class="menu-btn" @click="menuVisible = !menuVisible">
        <div class="line"></div>
      </div>
    </div>
    <div>
      
        
          <a href="/" class="site-nav">
            首页
          </a>
        
      
        
          <a href="/archives" class="site-nav">
            归档
          </a>
        
      
        
          <a href="/tags" class="site-nav">
            标签
          </a>
        
      
    </div>
  </div>
  <div class="bottom-container" data-aos="flip-up" data-aos-offset="0">
    <div class="social-container">
      
        
      
        
      
        
      
        
      
        
      
    </div>
    <div class="site-description">
      <strong> 岁月不堪数，故人不如初</strong>
    </div>
    <div class="site-footer">
      Powered by <a href="https://github.com/HealerLu" target="_blank">Healer Lu</a> | <a class="rss" href="https://HealerLu.github.io/atom.xml" target="_blank">RSS</a>
    </div>
  </div>
</div>


      <div class="main-container">
        <div class="content-container" data-aos="fade-up">
          <div class="post-detail">
            <h2 class="post-title">网络编程</h2>
            <div class="post-date">2020-09-18</div>
            
            <div class="post-content" v-pre>
              <h3 id="网络编程">网络编程</h3>
<h4 id="网络编程概述">网络编程概述</h4>
<h5 id="计算机网络">计算机网络</h5>
<ul>
<li>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来；在网络操作系统，网络管理软件及网络通讯协议的管理和协调下，实现资源共享和信息传递的计算机系统。</li>
</ul>
<h5 id="网络编程-2">网络编程</h5>
<ul>
<li>在网络通信协议下，实现网络互连的不同计算机上运行的程序可以进行数据交换。</li>
</ul>
<h4 id="网络编程三要素">网络编程三要素</h4>
<h5 id="ip地址">IP地址</h5>
<ul>
<li>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识</li>
</ul>
<blockquote>
<p>IP地址是网络中设备的唯一标识</p>
</blockquote>
<h6 id="ip地址分为两大类">IP地址分为两大类</h6>
<ul>
<li>IPv4 ：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每<br>
个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000<br>
00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制<br>
的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这<br>
种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多</li>
<li>IPv6 ：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发<br>
紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8<br>
组十六进制数，这样就解决了网络地址资源数量不够的问题</li>
</ul>
<h6 id="dos常用命令">DOS常用命令</h6>
<ul>
<li>ipconfig ：查看本机IP地址</li>
<li>ping IP 地址：检查网络是否连通</li>
</ul>
<h6 id="特殊-ip地址">特殊 IP地址：</h6>
<ul>
<li>127.0.0.1 ：是回送地址，可以代表本机地址，一般用来测试使用</li>
</ul>
<h6 id="inetaddress">InetAddress</h6>
<blockquote>
<p>InetAddress：此类表示Internet协议（IP）地址</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static InetAddress getbyName(String host)</td>
<td>确定主机名称的IP地址，主机名称可以是机器名称，也可以是IP地址</td>
</tr>
<tr>
<td>String getHostName()</td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td>String getHostAddress()</td>
<td>返回文本显示中的IP地址字符串</td>
</tr>
</tbody>
</table>
<h5 id="端口">端口</h5>
<blockquote>
<p>设备上应用程序的唯一标识</p>
</blockquote>
<ul>
<li>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识</li>
</ul>
<h6 id="端口号">端口号</h6>
<ul>
<li>用两个字节表示的整数，它的取值范围是 0<sub>65535。其中，0</sub>1023之间的端口号用于一些知名的网络服<br>
务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会<br>
导致当前程序启动失败</li>
</ul>
<h5 id="协议">协议</h5>
<blockquote>
<p>计算机网络中，连接和通信的规则被称为网络通信协议</p>
</blockquote>
<ul>
<li>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</li>
</ul>
<h6 id="udp协议">UDP协议</h6>
<ul>
<li>用户数据报协议 (User Datagram Protocol)</li>
<li>UDP 是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台<br>
计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在<br>
收到数据时，也不会向发送端反馈是否收到数据。</li>
<li>由于使用 UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</li>
<li>例如视频会议通常采用 UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太<br>
大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在<br>
传输重要数据时不建议使用UDP协议</li>
</ul>
<h6 id="tcp协议">TCP协议</h6>
<ul>
<li>传输控制协议 (Transmission Control Protocol)</li>
<li>TCP 协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数<br>
据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由<br>
客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”</li>
<li>三次握手： TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠
<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接</li>
</ul>
</li>
<li>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，<br>
TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等</li>
</ul>
<h3 id="udp通信程序">UDP通信程序</h3>
<blockquote>
<p>UDP协议是一种不可靠的网络协议，它在通信两端个建立了一个Socket对象，但是这两个Socket只是发送、接收数据的对象。因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念</p>
</blockquote>
<h4 id="udp发送数据">UDP发送数据</h4>
<h5 id="发送数据的步骤">发送数据的步骤</h5>
<ol>
<li>创建发送端的Socket对象(DatagramSocket)</li>
<li>创建数据，并把数据打包</li>
<li>调用DatagramSocket对象的方法发送数据</li>
<li>关闭发送端</li>
</ol>
<h5 id="示例">示例</h5>
<pre><code class="language-java">public class SendDemo {
  public static void main(String[] args) throws IOException {
    //创建发送端的Socket对象(DatagramSocket)
    // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口
    DatagramSocket ds = new DatagramSocket();
    //创建数据，并把数据打包
    //DatagramPacket(byte[] buf, int length, InetAddress address, int port)
    //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。
    byte[] bys = &quot;hello,udp,我来了&quot;.getBytes();
    DatagramPacket dp = new
DatagramPacket(bys,bys.length,InetAddress.getByName(&quot;192.168.120.66&quot;),10086);
    //调用DatagramSocket对象的方法发送数据
    //void send(DatagramPacket p) 从此套接字发送数据报包
    ds.send(dp);
    //关闭发送端
    //void close() 关闭此数据报套接字
    ds.close();
 }
}
</code></pre>
<h4 id="udp接收数据">UDP接收数据</h4>
<h5 id="接收数据的步骤">接收数据的步骤</h5>
<ol>
<li>创建接收端的Scoket对象(DatagramSocket)</li>
<li>创建一个数据包，用于接收数据</li>
<li>调用DatagramSocket对象的方法接收数据</li>
<li>解析数据包，并把数据在控制台显示</li>
<li>关闭接受端</li>
</ol>
<h5 id="示例-2">示例</h5>
<pre><code class="language-java">public class ReceiveDemo {
  public static void main(String[] args) throws IOException {
    //创建接收端的Socket对象(DatagramSocket)
    DatagramSocket ds = new DatagramSocket(12345);
    while (true) {
      //创建一个数据包，用于接收数据
      byte[] bys = new byte[1024];
      DatagramPacket dp = new DatagramPacket(bys, bys.length);
      //调用DatagramSocket对象的方法接收数据
      ds.receive(dp);
      //解析数据包，并把数据在控制台显示
      System.out.println(&quot;数据是：&quot; + new String(dp.getData(), 0,      
                dp.getLength()));
   }
 }
}
</code></pre>
<h3 id="tcp通信程序">TCP通信程序</h3>
<h4 id="tcp通信原理">TCP通信原理</h4>
<ul>
<li>TCP通信协议是一种可靠的网络协议，它再通信的两端个建立一个Socket对象，从而在通信的两端形成网络虚拟链路。一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信。</li>
<li>Java 对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过<br>
Socket产生IO流来进行网络通信。</li>
<li>Java 为客户端提供了Socket类，为服务器端提供了ServerSocket类</li>
</ul>
<h4 id="tcp发送数据">TCP发送数据</h4>
<h5 id="发送数据的步骤-2">发送数据的步骤</h5>
<ol>
<li>
<p>创建客户端的Socket对象(Socket)</p>
<ul>
<li>
<pre><code class="language-java">Socket(String host, int port);
</code></pre>
</li>
</ul>
</li>
<li>
<p>获取输出流，写数据</p>
<ul>
<li>
<pre><code class="language-java">OutputStream getOutputStream()
</code></pre>
</li>
</ul>
</li>
<li>
<p>释放资源</p>
<ul>
<li>
<pre><code class="language-java">void close()
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="tcp接收数据">TCP接收数据</h4>
<h5 id="接收数据的步骤-2">接收数据的步骤</h5>
<ol>
<li>
<p>创建服务器端的Socket对象(ServerSocket)</p>
<ul>
<li>
<pre><code class="language-java">ServerSocket(int port)
</code></pre>
</li>
</ul>
</li>
<li>
<p>监听客户端连接，返回一个Socket对象</p>
<ul>
<li>
<pre><code class="language-java">Socket accept()
</code></pre>
</li>
</ul>
</li>
<li>
<p>获取输入流，读数据，并把数据显示在控制台</p>
<ul>
<li>
<pre><code class="language-java">InputStream getInputStream()
</code></pre>
</li>
</ul>
</li>
<li>
<p>释放资源</p>
<ul>
<li>
<pre><code class="language-java">void close()
</code></pre>
</li>
</ul>
</li>
</ol>

            </div>
            
              <div class="tag-container">
                
                  <a href="https://HealerLu.github.io/tag/Vk-b-Atmn/" class="tag">
                    Java
                  </a>
                
              </div>
            
            
              <div class="next-post">
                <div class="next">下一篇</div>
                <a href="https://HealerLu.github.io/post/yz0_jex0Z/">
                  <h3 class="post-title">
                    多线程
                  </h3>
                </a>
              </div>
            

            

          </div>

        </div>
      </div>
    </div>

    <script src="https://unpkg.com/aos@next/dist/aos.js"></script>
<script type="application/javascript">

AOS.init();

var app = new Vue({
  el: '#app',
  data: {
    menuVisible: false,
  },
})

</script>


  <script src="https://cdn.bootcss.com/highlight.js/9.12.0/highlight.min.js"></script>
  <script>
    hljs.initHighlightingOnLoad()
  </script>





  </body>
</html>
