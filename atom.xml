<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://HealerLu.github.io</id>
    <title>Healer</title>
    <updated>2020-09-11T08:32:11.066Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://HealerLu.github.io"/>
    <link rel="self" href="https://HealerLu.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt; 岁月不堪数，故人不如初&lt;/strong&gt;</subtitle>
    <logo>https://HealerLu.github.io/images/avatar.png</logo>
    <icon>https://HealerLu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Healer</rights>
    <entry>
        <title type="html"><![CDATA[IO]]></title>
        <id>https://HealerLu.github.io/post/snHuB_DAz/</id>
        <link href="https://HealerLu.github.io/post/snHuB_DAz/">
        </link>
        <updated>2020-09-11T08:30:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="file">File</h3>
<h4 id="file类概述">File类概述</h4>
<blockquote>
<p>File是文件和目录路径名的抽象表示</p>
</blockquote>
<ul>
<li>文件和目录是可以通过File封装成对象的</li>
<li>对于File而言。其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转为具体存在的。</li>
</ul>
<h4 id="file类的构造方法">File类的构造方法</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">File(String pathname)</td>
<td style="text-align:center">通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td style="text-align:center">File(String parent, String child)</td>
<td style="text-align:center">从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td style="text-align:center">File(File parent, String child)</td>
<td style="text-align:center">从父抽象路径名和自路径名字符串创建新的File实例</td>
</tr>
</tbody>
</table>
<h4 id="file类创建功能">File类创建功能</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean createNewFile()</td>
<td style="text-align:center">当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td>
</tr>
<tr>
<td style="text-align:center">public boolean mkdir()</td>
<td style="text-align:center">创建由此抽象路径命名的目录</td>
</tr>
<tr>
<td style="text-align:center">public boolean mkdirs()</td>
<td style="text-align:center">创建由此抽象路径命名的目录，包括任何必须但不存在的父目录</td>
</tr>
</tbody>
</table>
<h5 id="file类的判断和获取功能">File类的判断和获取功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean isDirectory()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否为目录</td>
</tr>
<tr>
<td style="text-align:center">public boolean isFile()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td style="text-align:center">public boolean exists()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td style="text-align:center">public String getAbsoultePath()</td>
<td style="text-align:center">返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td style="text-align:center">public String getPath()</td>
<td style="text-align:center">将此抽象路径转换为路径名字符串</td>
</tr>
<tr>
<td style="text-align:center">public String getName()</td>
<td style="text-align:center">返回此抽线路径名表示的文件或目录的名称</td>
</tr>
<tr>
<td style="text-align:center">public String[] list()</td>
<td style="text-align:center">返回此抽象路径名标识的目录中的文件和目录的名称字符串数组</td>
</tr>
<tr>
<td style="text-align:center">public File[] listFiles()</td>
<td style="text-align:center">返回此抽象路径名表示的目录中的文件和目录的File对象数组</td>
</tr>
</tbody>
</table>
<h5 id="file类的删除功能">File类的删除功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean delete()</td>
<td style="text-align:center">删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody>
</table>
<h3 id="字节流">字节流</h3>
<h4 id="io流概述和分类">IO流概述和分类</h4>
<h5 id="io流概述">IO流概述</h5>
<ul>
<li>IO：输入/输出(input/Output)</li>
<li>流：是一种抽象概念，是对数据传输的总成。也就是说数据在设备间的传输称为流，流的本质是数据传输。</li>
<li>IO流就是用来处理设备间数据传输问题的，常见的应用：我呢见赋值、文件上传、文件下载</li>
</ul>
<h5 id="分类">分类</h5>
<ul>
<li>
<p>按照数据的流向</p>
<ul>
<li>输入流：读数据</li>
<li>输出流：写数据</li>
</ul>
</li>
<li>
<p>按照数据类型分类</p>
<ul>
<li>字节流
<ul>
<li>字节输入流、字节输出流</li>
</ul>
</li>
<li>字符流
<ul>
<li>字符输入流、字符输出流</li>
</ul>
</li>
</ul>
<blockquote>
<p>一般来说是按照数据类型来分的</p>
</blockquote>
</li>
</ul>
<h5 id="字节流写数据">字节流写数据</h5>
<h6 id="字节流抽象基类">字节流抽象基类</h6>
<ul>
<li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li>
<li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li>
</ul>
<h6 id="fileoutputstream文件输出流用于将数据写入file">FileOutputStream：文件输出流用于将数据写入file</h6>
<ul>
<li>FileOutputStream(String name)：创建文件输出流以指定的名称写入文件</li>
</ul>
<h6 id="使用字节输出流写数据的步骤">使用字节输出流写数据的步骤：</h6>
<ul>
<li>创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）</li>
<li>调用字节输出流对象的写数据方法</li>
<li>释放资源（关闭此文件输出流并释放与此流相关联的任何系统资源）</li>
</ul>
<h6 id="字节流写数据的方法">字节流写数据的方法</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void write(int b)</td>
<td style="text-align:center">将指定的字节写入此文件输出流<br />一次写一个字节数据</td>
</tr>
<tr>
<td style="text-align:center">void write(byte[] b)</td>
<td style="text-align:center">将b.lenght字节从指定得字节数组写入此文件输出流<br />一次写一个字节的数据</td>
</tr>
<tr>
<td style="text-align:center">void write(byte[] b, int off, int len)</td>
<td style="text-align:center">将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流<br />一次写一个字节数组的部分数据</td>
</tr>
</tbody>
</table>
<h6 id="字节流写数据实现换行">字节流写数据实现换行</h6>
<pre><code class="language-java">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);

for (int i = 0; i &lt; 10; i ++) {
    fos.write(&quot;hello&quot;.getBytes());
    // 实现换行   windows：\r\n   linux：\n mac: \r
    fos.write(&quot;\r\n&quot;.getBytes());
}
// 释放资源
fos.close();
</code></pre>
<h6 id="字节流写数据实现追加写入">字节流写数据实现追加写入</h6>
<ul>
<li>public FileOutputStream(String name, boolean append)</li>
<li>创建文件输出流以指定的名称写入文件，如果第二个参数为true，则字节将写入文件的末尾而不是开头</li>
</ul>
<h6 id="字节流写数据加异常处理">字节流写数据加异常处理</h6>
<ul>
<li>finally：在异常处理时提供finally块来执行所有清除操作。比如IO流中的释放资源</li>
<li>特点：被finally控制的语句一定会执行，除非JVM退出</li>
</ul>
<pre><code class="language-java">try{
    // 可能出现异常的代码
}catch(异常类名 变量名) {
    // 异常的处理代码
} finally{
    // 执行所有的清楚操作
}
</code></pre>
<pre><code class="language-java">FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(&quot;Z:\\test&quot;);
            fos.write(&quot;Hello&quot;.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
</code></pre>
<h5 id="字节缓冲流">字节缓冲流</h5>
<ul>
<li>BufferedOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</li>
<li>BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从包含的输入流中重新填充，一次很多字节</li>
</ul>
<h6 id="构造方法">构造方法</h6>
<ul>
<li>字节缓冲输出流：BufferedOutputStream(OutputStream out)</li>
<li>字节缓冲输入流：BufferedInputStream(InputStream in)</li>
<li>构造方法需要的是字节流而不是具体的文件或者路径，是因为字节缓冲流仅仅提供缓冲区域，而真正读写数据还得依靠基本的字节流对象进行操作</li>
</ul>
<h3 id="字符流">字符流</h3>
<h4 id="为什么会出现字符流">为什么会出现字符流</h4>
<blockquote>
<p>由于字节流操作中文不是特别的方便，所以Java就提供了字符流</p>
</blockquote>
<ul>
<li>字符流 = 字节流 + 编码表</li>
</ul>
<h4 id="字符串中的编码解码问题">字符串中的编码解码问题</h4>
<h5 id="相关方法">相关方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte[] getBytes()</td>
<td style="text-align:center">使用平台的默认字符集将该 String编码为一系列字节</td>
</tr>
<tr>
<td style="text-align:center">byte[] getBytes(String charsetName)</td>
<td style="text-align:center">使用指定的字符集将该 String编码为一系列字节</td>
</tr>
<tr>
<td style="text-align:center">String(byte[] bytes)</td>
<td style="text-align:center">使用平台的默认字符集解码指定的字节数组来创建字符串</td>
</tr>
<tr>
<td style="text-align:center">String(byte[] bytes, String charsetName)</td>
<td style="text-align:center">通过指定的字符集解码指定的字节数组来创建字符串</td>
</tr>
</tbody>
</table>
<h4 id="字符流中的编码解码问题">字符流中的编码解码问题</h4>
<h5 id="字符流抽象基类">字符流抽象基类</h5>
<ul>
<li>Reader：字符输入流的抽象类</li>
<li>Writer：字符输出流的抽象类</li>
</ul>
<h5 id="字符流中和编码解码问题相关的两个类">字符流中和编码解码问题相关的两个类</h5>
<ul>
<li>InputStreamReader     字符输入流</li>
<li>OutputStreamWriter    字符输出流</li>
</ul>
<h5 id="便捷转换类">便捷转换类</h5>
<ul>
<li>FileReader：用于读取字符文件的便捷类
<ul>
<li>File Reader(String fileName)</li>
</ul>
</li>
<li>FileWriter：用于写入字符文件的便捷类
<ul>
<li>FileWriter(String fileName)</li>
</ul>
</li>
</ul>
<h4 id="字符流写数据的5种方式">字符流写数据的5种方式</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void write(int c)</td>
<td style="text-align:center">写一个字符</td>
</tr>
<tr>
<td style="text-align:center">void write(char[] cbuf)</td>
<td style="text-align:center">写入一个字符数组</td>
</tr>
<tr>
<td style="text-align:center">void write(char[] cbuf, int off, int len)</td>
<td style="text-align:center">写入字符数组的一部分</td>
</tr>
<tr>
<td style="text-align:center">void write(String str)</td>
<td style="text-align:center">写一个字符串</td>
</tr>
<tr>
<td style="text-align:center">void write(String str, int off, int len)</td>
<td style="text-align:center">写一个字符串的一部分</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flush()</td>
<td style="text-align:center">刷新流，还可以继续写数据</td>
</tr>
<tr>
<td style="text-align:center">close()</td>
<td style="text-align:center">关闭流，释放资源，但是在关闭前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody>
</table>
<h4 id="字符流读数据的2种方式">字符流读数据的2种方式</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int read()</td>
<td style="text-align:center">一次读一个字符数据</td>
</tr>
<tr>
<td style="text-align:center">int read(char[] cbuf)</td>
<td style="text-align:center">一次读一个字符数组数据</td>
</tr>
</tbody>
</table>
<h4 id="字符缓冲流">字符缓冲流</h4>
<h5 id="字符缓冲流-2">字符缓冲流</h5>
<ul>
<li>BufferedWriter ：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可<br>
以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</li>
<li>BufferedReader ：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓<br>
冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途</li>
</ul>
<h5 id="构造方法-2">构造方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedWriter(Writer out)</td>
<td style="text-align:center">创建字符缓冲输出流对象</td>
</tr>
<tr>
<td style="text-align:center">BufferedReader(Reader in)</td>
<td style="text-align:center">创建字符缓冲输入流对象</td>
</tr>
</tbody>
</table>
<h4 id="字符缓冲流的特有功能">字符缓冲流的特有功能</h4>
<ul>
<li>BufferedWriter
<ul>
<li>void newLine()：写一行行分隔符，行分隔符字符串由系统属性定义</li>
</ul>
</li>
<li>BufferedReader:
<ul>
<li>public String readLine()：读一行文字。结果包含行的内容字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null</li>
</ul>
</li>
</ul>
<h3 id="io流小结">IO流小结</h3>
<h5 id="字节流-2">字节流</h5>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200911154542655.png" alt="image-20200911154542655" loading="lazy"></figure>
<h5 id="字符流-2">字符流</h5>
<figure data-type="image" tabindex="2"><img src="https://HealerLu.github.io/post-images/image-20200911154617711.png" alt="image-20200911154617711" loading="lazy"></figure>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合]]></title>
        <id>https://HealerLu.github.io/post/f-4HJd9X2/</id>
        <link href="https://HealerLu.github.io/post/f-4HJd9X2/">
        </link>
        <updated>2020-09-09T06:58:09.000Z</updated>
        <content type="html"><![CDATA[<h4 id="集合类体系结构">集合类体系结构</h4>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200902164026717.png" alt="image-20200902164026717" loading="lazy"></figure>
<h5 id="collection集合概述和使用">Collection集合概述和使用</h5>
<h6 id="概述">概述</h6>
<ul>
<li>Collection集合是单列集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素</li>
<li>JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现</li>
</ul>
<h5 id="创建collection集合的对象">创建Collection集合的对象</h5>
<ul>
<li>多态的方式</li>
<li>具体的实现类ArrayList</li>
</ul>
<blockquote>
<p><code>Collection&lt;String&gt; c = new ArrayList&lt;String &gt;();</code></p>
</blockquote>
<h5 id="collection集合常用方法">Collection集合常用方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean add(E e)</td>
<td style="text-align:center">添加元素</td>
</tr>
<tr>
<td style="text-align:center">boolean remove(Object o)</td>
<td style="text-align:center">从几何中移除指定的元素</td>
</tr>
<tr>
<td style="text-align:center">void colear()</td>
<td style="text-align:center">清空集合中的元素</td>
</tr>
<tr>
<td style="text-align:center">boolean contains(Object 0)</td>
<td style="text-align:center">判断几何中是否存在指定的元素</td>
</tr>
<tr>
<td style="text-align:center">boolean isEmpty()</td>
<td style="text-align:center">判断集合是否为空</td>
</tr>
<tr>
<td style="text-align:center">int size()</td>
<td style="text-align:center">集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody>
</table>
<h5 id="collection集合的遍历">Collection集合的遍历</h5>
<h6 id="iterator迭代器集合的专用遍历方式">Iterator：迭代器，集合的专用遍历方式</h6>
<ul>
<li>Iterator<E> iterator()：返回此几何中元素的迭代器，通过集合的iterator()方法得到</li>
<li>迭代器是通过集合的iterator()方法得到的，所以我们说他是抵赖于集合而存在的</li>
</ul>
<h6 id="iterator中常用的方法">Iterator中常用的方法</h6>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
</ul>
<pre><code class="language-java">// 创建集合对象
Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();
// 向集合里面添加元素
c.add(&quot;Demo1&quot;);
c.add(&quot;Demo2&quot;);
c.add(&quot;Demo3&quot;);
c.add(&quot;Demo4&quot;);
// 创建迭代器
Iterator&lt;String&gt; it = c.iterator();
while (it.hasNext()) {
    String s = it.next();
    System.out.println(s);
}
</code></pre>
<h5 id="list集合概述和特点">List集合概述和特点</h5>
<h6 id="list集合概述">List集合概述</h6>
<ul>
<li>有序集合（也成为序列），用户可以景区控制列表中每个元素的插入位置，可以通过整数索引访问元素并搜索列表中的元素</li>
<li>与Set集合不同，列表通常允许重复的元素</li>
</ul>
<h6 id="list集合特点">List集合特点</h6>
<ul>
<li>
<p>有序：存储和取出的元素顺序一致</p>
</li>
<li>
<p>可重复：存储的元素可以重复</p>
<pre><code class="language-java">List&lt;String&gt; l = new ArrayList&lt;String&gt;();

l.add(&quot;1&quot;);
l.add(&quot;2&quot;);
l.add(&quot;3&quot;);
l.add(&quot;3&quot;);

//System.out.println(l); [1, 2, 3, 3]
// 迭代器方式遍历
Iterator&lt;String&gt; iterator = l.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
    System.out.println(s);
}
</code></pre>
</li>
</ul>
<h6 id="list集合的特有方法">List集合的特有方法</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void add(int index, E element)</td>
<td style="text-align:center">在此几何中的指定位置插入指定的元素</td>
</tr>
<tr>
<td style="text-align:center">E remove(int index)</td>
<td style="text-align:center">删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td style="text-align:center">E set(int index, E element)</td>
<td style="text-align:center">修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td style="text-align:center">E get(int index)</td>
<td style="text-align:center">返回指定索引处的元素</td>
</tr>
</tbody>
</table>
<h6 id="listiterator">ListIterator</h6>
<blockquote>
<p>ListIterator：列表迭代器</p>
</blockquote>
<ul>
<li>通过List集合的listiterator()方法得到，所以说它是List集合特有的迭代器</li>
<li>用于允许程序沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。</li>
</ul>
<blockquote>
<p>常用方法</p>
</blockquote>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
<li>E previous()：返回列表重的上一个元素</li>
<li>boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true</li>
<li>void add(E e)：将指定的元素插入列表</li>
</ul>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();

list.add(&quot;1&quot;);
list.add(&quot;2&quot;);
list.add(&quot;3&quot;);
// 正向遍历
ListIterator&lt;String&gt; iterator = list.listIterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
// 逆向遍历
while (iterator.hasPrevious()) {
    System.out.println(iterator.previous());
}
// 添加
while (iterator.hasNext()) {
    String s = iterator.next();
    if (s.equals(&quot;1&quot;)) {
        iterator.add(&quot;4&quot;);
    }
}
System.out.println(list);
</code></pre>
<h6 id="增强for循环">增强for循环</h6>
<blockquote>
<p>简化数组和Collection集合的遍历</p>
</blockquote>
<ul>
<li>实现Iterable接口的类允许其对象成为增强型for语句的目标</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li>
</ul>
<blockquote>
<p>增强for的格式</p>
</blockquote>
<pre><code class="language-java">for(元素数据类型 变量名:数组或者Collection集合){
    // 在此处使用变量即可，该变量就是元素
}
</code></pre>
<blockquote>
<p>范例</p>
</blockquote>
<pre><code class="language-java">int[] arr = {1, 2, 3, 4, 5};
for(int i : arr){
    System.out.println(i);
}
</code></pre>
<h6 id="list集合子类特点">List集合子类特点</h6>
<blockquote>
<p>list集合常用子类：ArrayList、LinkedList</p>
</blockquote>
<ul>
<li>ArrayList：底层数据结构是数组，查询快，增删慢</li>
<li>LinkedList：底层数据结构是链表，查询慢，增删快</li>
</ul>
<h6 id="linkedlist集合的特有功能">LinkedList集合的特有功能</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void addFirst(E e)</td>
<td style="text-align:center">在该列表开头插入指定的元素</td>
</tr>
<tr>
<td style="text-align:center">public void addLast(E e)</td>
<td style="text-align:center">将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td style="text-align:center">public void getFirst()</td>
<td style="text-align:center">返回此列表中的第一个元素</td>
</tr>
<tr>
<td style="text-align:center">public getLast()</td>
<td style="text-align:center">返回此列表重的最后一个元素</td>
</tr>
<tr>
<td style="text-align:center">public E removeFirst()</td>
<td style="text-align:center">从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td style="text-align:center">public E removeLast()</td>
<td style="text-align:center">从此列表中删除并返回最后一个元素</td>
</tr>
</tbody>
</table>
<h5 id="set集合">Set集合</h5>
<h6 id="set集合概述和特点">Set集合概述和特点</h6>
<ul>
<li>不包含重复元素的集合</li>
<li>没有带索引的方法，所以不能使用普通的for循环</li>
</ul>
<pre><code class="language-java">// 创建HashSet并遍历
Set&lt;Integer&gt; set = new HashSet&lt;&gt;();

set.add(1);
set.add(2);
set.add(3);

Iterator&lt;Integer&gt; it = set.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
System.out.println(set);
</code></pre>
<h6 id="哈希值">哈希值</h6>
<blockquote>
<p>哈希值是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
<p>Object类中的<code>public int hashCode()</code>方法可以返回对象的哈希码值</p>
</blockquote>
<blockquote>
<p>对象的哈希值特点</p>
</blockquote>
<ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li>
</ul>
<h6 id="linkedhashset集合的概述和特点">LinkedHashSet集合的概述和特点</h6>
<ul>
<li>hash表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h6 id="treeset集合概述和特点">TreeSet集合概述和特点</h6>
<ul>
<li>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法。
<ul>
<li>TreeSet()：根据元素的自然排序进行排序。</li>
<li>TreeSet(Comparator comparator)：根据指定的比较器进行排序。</li>
</ul>
</li>
<li>没有带索引的方法，所以不能使用普通for循环遍历</li>
<li>由于是Set集合，所以不包含重复元素</li>
</ul>
<h6 id="自然排序comparable的使用">自然排序Comparable的使用</h6>
<ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(To)方法</li>
</ul>
<h6 id="比较器排序comparator的使用">比较器排序Comparator的使用</h6>
<ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序就是让集合构造方法接收Comparator的实现类对象，重写compareTo(To1, To2)方法</li>
</ul>
<h4 id="泛型">泛型</h4>
<h5 id="泛型概述">泛型概述</h5>
<blockquote>
<p>泛型：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型<br>
它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方<br>
法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具<br>
体的类型参数化，然后在使用/调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称<br>
为泛型类、泛型方法、泛型接口</p>
</blockquote>
<h5 id="泛型定义格式">泛型定义格式</h5>
<ul>
<li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参</li>
<li>&lt;类型1，类型2...&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</li>
<li>将来具体调用的时候给定的类型可以看成是实参，并且实参的类型行只能是引用数据类型</li>
</ul>
<h5 id="泛型的好处">泛型的好处</h5>
<ul>
<li>把运行时期的问题提前到了编译期间</li>
<li>避免了强制类型转换</li>
</ul>
<h5 id="泛型类">泛型类</h5>
<h6 id="泛型类的定义格式">泛型类的定义格式</h6>
<ul>
<li>修饰符 class 类名 &lt;类型&gt; {}</li>
</ul>
<pre><code class="language-java">public class Demo&lt;T&gt;{
    // 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
}
</code></pre>
<h5 id="泛型方法">泛型方法</h5>
<h6 id="泛型方法的定义格式">泛型方法的定义格式</h6>
<ul>
<li>修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名){}</li>
</ul>
<pre><code class="language-java">public &lt;T&gt; void show(T t){}
</code></pre>
<pre><code class="language-java">// 类
public class Generic{
    // 定义泛型方法
    public &lt;T&gt; void show(T t){
        System.out.println(t);
    }
}
// 使用
public static void main(String[] args) {
    Generic g = new Generic();
    g.show(30);
    g.show(&quot;张三&quot;);
}
</code></pre>
<h5 id="泛型接口">泛型接口</h5>
<h6 id="泛型接口的定义格式">泛型接口的定义格式</h6>
<ul>
<li>修饰符 interface 接口名 &lt;类型&gt; {}</li>
</ul>
<pre><code class="language-java">public interface Generic&lt;T&gt;{}
</code></pre>
<h5 id="类型通配符">类型通配符</h5>
<h6 id="类型通配符概述">类型通配符概述</h6>
<ul>
<li>为了表示各种泛型List的父类。可以使用类型通配符</li>
<li>类型通配符：&lt;?&gt;</li>
<li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型</li>
<li>这种代通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li>
</ul>
<blockquote>
<p>如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
</blockquote>
<ul>
<li>
<p>类型通配符上限：&lt;? extends 类型&gt;</p>
</li>
<li>
<pre><code class="language-java">List&lt;? extends Number&gt; //表示的类型是Number或者其子类型
</code></pre>
</li>
</ul>
<blockquote>
<p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p>
</blockquote>
<ul>
<li>
<p>类型通配符下限：&lt;? super 类型&gt;</p>
</li>
<li>
<pre><code class="language-java">List&lt;? super Number&gt; //表示的类型是Number或者其父类型
</code></pre>
</li>
</ul>
<h5 id="可变参数">可变参数</h5>
<h6 id="可变参数概述">可变参数概述</h6>
<ul>
<li>
<p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数的格式就是可变的了</p>
</li>
<li>
<p>格式：修饰符 返回值类型 方法名(数据类型... 变量名){}</p>
</li>
<li>
<pre><code class="language-java">public static int sun(int... a){}
</code></pre>
</li>
</ul>
<h6 id="可变参数的使用">可变参数的使用</h6>
<blockquote>
<p>Arrays工具类中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <T> List<T> asList(T... a)：返回由指定数组支持的固定大小的列表</li>
<li>返回的集合不能做增删操作，可以做修改操作</li>
</ul>
<blockquote>
<p>List接口中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <E> List <E> of (E... elements)：返回包含任意数量元素的不可变列表</li>
<li>返回的集合不能做增删改操作</li>
</ul>
<blockquote>
<p>Set接口中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <E> Set <E> of (E... element)：返回一个包含任意数量元素的不可变集合</li>
<li>返回的集合不能做增删操作，没有修改的方法</li>
<li>再给元素的时候，不能给重复的元素</li>
</ul>
<h4 id="map集合">Map集合</h4>
<h5 id="map集合的概述和使用">Map集合的概述和使用</h5>
<ul>
<li>Interface Map&lt;K,V&gt;      K：键的类型      V：值的类型</li>
<li>将键映射到值得对象，不能包含重复的键，每个键可以映射到最多一个值</li>
</ul>
<h5 id="创建map集合的对象">创建Map集合的对象</h5>
<ul>
<li>多态的方式</li>
<li>具体的实现类HashMap</li>
</ul>
<h5 id="map集合的基本功能">Map集合的基本功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V put(K key, V value)</td>
<td style="text-align:center">添加元素</td>
</tr>
<tr>
<td style="text-align:center">V remove(Object key)</td>
<td style="text-align:center">根据键删除键值对元素</td>
</tr>
<tr>
<td style="text-align:center">void clear()</td>
<td style="text-align:center">移除所有的键值对元素</td>
</tr>
<tr>
<td style="text-align:center">boolean containsKey(Object key)</td>
<td style="text-align:center">判断集合是否包含制定的键</td>
</tr>
<tr>
<td style="text-align:center">boolean containsValue(Object value)</td>
<td style="text-align:center">判断集合是否包含指定的值</td>
</tr>
<tr>
<td style="text-align:center">boolean isEmpty()</td>
<td style="text-align:center">判断集合是否为空</td>
</tr>
<tr>
<td style="text-align:center">int size()</td>
<td style="text-align:center">集合的长度，也就是几何中键值对的个数</td>
</tr>
</tbody>
</table>
<h5 id="map集合的获取功能">Map集合的获取功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V get(Object key)</td>
<td style="text-align:center">根据键获取值</td>
</tr>
<tr>
<td style="text-align:center">Set<K> keySet()</td>
<td style="text-align:center">获取所有键的集合</td>
</tr>
<tr>
<td style="text-align:center">Collection<V> values()</td>
<td style="text-align:center">获取所有值的集合</td>
</tr>
<tr>
<td style="text-align:center">Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet</td>
<td style="text-align:center">获取所有键值对对象的集合</td>
</tr>
</tbody>
</table>
<h5 id="map的遍历">Map的遍历</h5>
<h6 id="方法一">方法一：</h6>
<pre><code class="language-java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

map.put(&quot;张三&quot;, &quot;20岁&quot;);
map.put(&quot;李四&quot;, &quot;30岁&quot;);
map.put(&quot;王五&quot;, &quot;40岁&quot;);
// 获取键
Set&lt;String&gt; keySet = map.keySet();

for(String key : keySet) {
    // 根据键获取值
    String value = map.get(key);
    System.out.println(key + &quot;,&quot; + value);
    /*李四,30岁
            张三,20岁
            王五,40岁*/
}
</code></pre>
<h6 id="方法二">方法二：</h6>
<pre><code class="language-java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

map.put(&quot;张三&quot;, &quot;20岁&quot;);
map.put(&quot;李四&quot;, &quot;30岁&quot;);
map.put(&quot;王五&quot;, &quot;40岁&quot;);
// 获取所有键值对
Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();

for (Map.Entry&lt;String, String&gt; me : entrySet) {
    // 获取键
    String key = me.getKey();
    // 获取值
    String value = me.getValue();
    System.out.println(key + &quot;，&quot; + value);
}
</code></pre>
<h5 id="集合嵌套之arraylist嵌套hashmap">集合嵌套之ArrayList嵌套HashMap</h5>
<pre><code class="language-java">// 创建ArrayList集合
ArrayList&lt;HashMap&lt;String, String&gt;&gt; array = new ArrayList&lt;&gt;();
// 创建HashMap集合
HashMap&lt;String, String&gt; hm1 = new HashMap&lt;&gt;();
// 将键值对添加到HashMap
hm1.put(&quot;张三&quot;, &quot;20&quot;);
// 将HashMap添加到ArrayList集合
array.add(hm1);

HashMap&lt;String, String&gt; hm2 = new HashMap&lt;&gt;();
hm2.put(&quot;李四&quot;, &quot;30&quot;);
array.add(hm2);

HashMap&lt;String, String&gt; hm3 = new HashMap&lt;&gt;();
hm3.put(&quot;王五&quot;, &quot;40&quot;);
array.add(hm3);

// 遍历ArrayList集合
for (HashMap&lt;String, String&gt; hm : array) {
    // 获取HashMap的键
    Set&lt;String&gt; keySet = hm.keySet();
    for (String key : keySet) {
        // 根据键获取值
        String value = hm.get(key);
        // 循环输出
        System.out.println(key + &quot;---&quot; + value);
    }
}
</code></pre>
<h4 id="collections">Collections</h4>
<h5 id="collections类的概述">Collections类的概述</h5>
<ul>
<li>是针对集合操作的工具类</li>
</ul>
<h5 id="collections类的常用方法">Collections类的常用方法</h5>
<ul>
<li><code>public static &lt;T ectends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>：将制定的列表按升序排序</li>
<li><code>public static void reverse(List&lt;?&gt; list)</code>：反转指定列表中元素的顺序</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>：使用默认的随机源随机排列指定的列表</li>
</ul>
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

list.add(10);
list.add(50);
list.add(40);
list.add(20);

// Collections.sort(list);    // 排序
// Collections.reverse(list); // 反转
// Collections.shuffle(list); // 随机置换

System.out.println(list);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多态]]></title>
        <id>https://HealerLu.github.io/post/8rKXVY6sg/</id>
        <link href="https://HealerLu.github.io/post/8rKXVY6sg/">
        </link>
        <updated>2020-08-28T08:41:43.000Z</updated>
        <content type="html"><![CDATA[<h4 id="多态概述">多态概述</h4>
<blockquote>
<p>同一个对象，在不同时刻表现出来的不同形态。</p>
</blockquote>
<h5 id="多态的前提和体现">多态的前提和体现</h5>
<ul>
<li>
<p>有继承/实现关系</p>
</li>
<li>
<p>有方法重写</p>
</li>
<li>
<p>有父类引用指向子类对象</p>
</li>
<li>
<p>多态中成员访问特点</p>
<ul>
<li>成员变量：编译看左边，执行看左边</li>
<li>成员方法：编译看左边，执行看右边</li>
</ul>
<blockquote>
<p>因为成员方法有重写，而成员变量没有，所以成员变量和成员方法的访问不一样</p>
</blockquote>
</li>
</ul>
<h5 id="多态的好处和弊端">多态的好处和弊端</h5>
<ul>
<li>
<p>多态的好处：提高了程序的扩展性</p>
<blockquote>
<p>具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作</p>
</blockquote>
</li>
<li>
<p>多态的弊端：不能使用子类的特有功能</p>
</li>
</ul>
<h5 id="多态中的转型">多态中的转型</h5>
<ul>
<li>
<p>向上转型</p>
<ul>
<li>
<p>从子到父</p>
<blockquote>
<p>父类引用指向子类对象</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>向下转型</p>
<ul>
<li>
<p>从父到子</p>
<blockquote>
<p>父类引用转为子类对象</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="抽象类">抽象类</h4>
<ul>
<li>
<p>概述</p>
<blockquote>
<p>在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。</p>
</blockquote>
</li>
<li>
<p>抽象类的特点</p>
<ul>
<li>抽象类和抽象方法必须使用abstract关键字修饰</li>
<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>
<li>抽象类不能实例化。但是抽象类可以参照多态的方法，通过子类对象实例化，这叫抽象类多态。</li>
<li>抽象类的子类
<ul>
<li>要么重写抽象类中的所有抽象方法</li>
<li>要么是抽象类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>抽象类的成员特点</p>
<ul>
<li>成员变量
<ul>
<li>可以是常量，也可以是变量</li>
</ul>
</li>
<li>构造方法
<ul>
<li>有构造方法但是不能实例化。是用于子类访问父类数据的初始化。</li>
</ul>
</li>
<li>成员方法
<ul>
<li>可以有抽象方法：限定子类必须完成某些动作</li>
<li>也可以有非抽象方法：提高代码的复用性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="接口">接口</h4>
<ul>
<li>
<p>概述</p>
<blockquote>
<p>接口就是一种公共的规范标准，只要付个规范标准。大家都可以通用。Java中的接口更多的体现在对行为的抽象</p>
</blockquote>
</li>
<li>
<p>接口的成员特点</p>
<ul>
<li>成员变量只能是常量，默认修饰符： <code>public static final</code></li>
<li>接口中没有构造方法，因为接口主要是对行为进行抽象，是没有具体存在的。一个类中如果没有父类，默认继承自Object类</li>
</ul>
</li>
<li>
<p>成员方法</p>
<ul>
<li>只能是抽象方法，默认修饰符<code>public abstract</code></li>
</ul>
</li>
<li>
<p>类和类的关系</p>
<ul>
<li>类和类的关系是继承关系，只能单继承，但是可以多继承</li>
</ul>
</li>
<li>
<p>类和接口的关系</p>
<ul>
<li>类和接口是实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口</li>
</ul>
</li>
<li>
<p>接口和接口的关系</p>
<ul>
<li>接口和接口是继承关系，可以单继承也可以多继承</li>
</ul>
</li>
<li>
<p>抽象类和接口的区别</p>
<ul>
<li>
<p>成员区别</p>
<ul>
<li>抽象类：变量、常量；有构造方法，有抽象方法，也有非抽象方法</li>
<li>接口：常量；抽象方法</li>
</ul>
</li>
<li>
<p>关系区别</p>
<ul>
<li>类与类：继承，单继承</li>
<li>类与接口： 实现，可以单实现，也可以多实现</li>
<li>接口与接口：继承，单继承，也可以多继承</li>
</ul>
</li>
<li>
<p>设计理念区别</p>
<ul>
<li>抽象类： 对类抽象，包括属性行为</li>
<li>接口：对行为抽象，主要是行为</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[继承]]></title>
        <id>https://HealerLu.github.io/post/0RqKWGXkz/</id>
        <link href="https://HealerLu.github.io/post/0RqKWGXkz/">
        </link>
        <updated>2020-08-27T09:40:09.000Z</updated>
        <content type="html"><![CDATA[<h4 id="继承概述">继承概述</h4>
<ul>
<li>
<p>概述</p>
<ul>
<li>继承是面向对象的三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。</li>
</ul>
</li>
<li>
<p>格式</p>
<ul>
<li><code>public class 子类名 extends 父类名 {}</code></li>
</ul>
</li>
<li>
<p>继承中子类的特点</p>
<ul>
<li>子类可以有父类的内容</li>
<li>子类还可以有自己特有的内容</li>
</ul>
</li>
<li>
<p>继承的好处</p>
<ul>
<li>提高了代码的复用性（多个类相同的成员可以放到同一个类中）</li>
<li>提高了代码的维护性（如果方法的代码需要修改，修改一处即可）</li>
</ul>
</li>
<li>
<p>继承的弊端</p>
<ul>
<li>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性</li>
</ul>
</li>
<li>
<p>super关键字</p>
<ul>
<li>
<p>super关键字的用法和this关键字的用法相似，this代表本类对象的引用</p>
</li>
<li>
<p>super代表父类存储空间的标识（也可以理解为是父类空间的引用）</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">访问成员变量</th>
<th style="text-align:center">访问构造方法</th>
<th style="text-align:center">访问成员方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">this</td>
<td style="text-align:center">this.成员变量<br />访问本类成员变量</td>
<td style="text-align:center">this(...)<br />访问本类构造方法</td>
<td style="text-align:center">this.成员方法(...)<br />访问本类成员方法</td>
</tr>
<tr>
<td style="text-align:center">super</td>
<td style="text-align:center">super.成员变量<br />访问父类成员变量</td>
<td style="text-align:center">super(...)<br />访问父类构造方法</td>
<td style="text-align:center">super.成员方法(...)<br />访问父类成员方法</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>继承中构造方法的访问特点</p>
<ul>
<li>子类中所有的构造方法默认都会访问父类中无参的构造方法
<ul>
<li>因为子类汇集成父类中的数据，可能还会使用父类的数据，所以子类初始化之前，一定要先完成父类数据的初始化</li>
<li>每一个子类构造方法的第一条语句默认都是：<strong>super()</strong></li>
</ul>
</li>
<li>如果父类中没有无参构造方法，只有代餐构造方法，报错的解决方案
<ul>
<li>通过使用<strong>super</strong>关键字去显式的调用父类的带参构造方法</li>
<li>在父类中自己提供一个无参构造方法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>继承中成员方法的访问特点</p>
<ul>
<li>通过子类对象访问一个方法
<ul>
<li>首先会在子类的成员范围内找</li>
<li>其次在父类的成员范围内找</li>
<li>如果都没有就报错（不考虑父亲的父亲）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="方法重写">方法重写</h4>
<ul>
<li>概述
<ul>
<li>子类中出现了和父类中一模一样的方法声明</li>
</ul>
</li>
<li>方法重写的应用
<ul>
<li>当子类需要父类的功能，而功能主体子类有自己特有内用时，可以重写父类中的方法。这样即沿袭了父类的功能，又定义了子类特有的内容。</li>
</ul>
</li>
<li>方法重写的注意事项
<ul>
<li>私有方法不能被重写（父类私有成员子类是不能够继承的）</li>
<li>子类方法访问权限不能更低（public &gt; 默认 &gt; 私有）</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[修饰符]]></title>
        <id>https://HealerLu.github.io/post/Ds88JizU3/</id>
        <link href="https://HealerLu.github.io/post/Ds88JizU3/">
        </link>
        <updated>2020-08-27T09:38:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="修饰符的分类">修饰符的分类</h4>
<ul>
<li>
<p>权限修饰符</p>
</li>
<li>
<p>状态修饰符</p>
<h5 id="权限修饰符">权限修饰符</h5>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">同一个类中</th>
<th style="text-align:center">同一个包中子类无关类</th>
<th style="text-align:center">不同包的子类</th>
<th style="text-align:center">不同包的无关类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
<td style="text-align:center">✘</td>
<td style="text-align:center">✘</td>
</tr>
<tr>
<td style="text-align:center">默认</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
<td style="text-align:center">✘</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
</tr>
</tbody>
</table>
<h5 id="状态修饰符">状态修饰符</h5>
<ul>
<li>final （最终态）</li>
<li>static（静态）</li>
</ul>
<h6 id="final">final</h6>
<ul>
<li>
<p>final关键字是最终的意思，可以修饰成员方法、成员变量、类</p>
</li>
<li>
<p>final修饰的特点</p>
<ul>
<li>修饰方法：表明该方法是最终方法，不能被重写</li>
<li>修饰变量：表明该变量是常量，不能被再次赋值</li>
<li>修饰类：表明该类是最终类，不能被继承</li>
</ul>
</li>
</ul>
<h6 id="static">static</h6>
<ul>
<li>
<p>static关键字是静态的意思，可以修饰成员方法、成员变量</p>
</li>
<li>
<p>static修饰的特点</p>
<ul>
<li>被类的所有对象共享（这也判断是否使用静态修饰符的条件）</li>
<li>可以通过类名调用（也可以通过对象名调用）</li>
</ul>
</li>
<li>
<p>static访问特点</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">静态成员变量</th>
<th style="text-align:center">非静态成员变量</th>
<th style="text-align:center">静态成员方法</th>
<th style="text-align:center">非静态成员方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">非静态成员方法</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
</tr>
<tr>
<td style="text-align:center">静态成员方法</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
</tr>
</tbody>
</table>
<blockquote>
<p>静态成员方法只能访问静态成员</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象基础]]></title>
        <id>https://HealerLu.github.io/post/rBwY8CzIg/</id>
        <link href="https://HealerLu.github.io/post/rBwY8CzIg/">
        </link>
        <updated>2020-08-24T03:30:53.000Z</updated>
        <content type="html"><![CDATA[<h4 id="类">类</h4>
<blockquote>
<p>类是对现实生活中一类具有共同属性和行为的事物的抽象</p>
</blockquote>
<ul>
<li>类的特点
<ul>
<li>类是对象的数据类型</li>
<li>类是具有相同属性和行为的一组对象的合集</li>
</ul>
</li>
</ul>
<h4 id="对象的属性">对象的属性</h4>
<blockquote>
<p>对象具有各种特征，每个对象的每个属性都有特定的值</p>
</blockquote>
<h4 id="对象的行为">对象的行为</h4>
<blockquote>
<p>对象能够执行的操作</p>
</blockquote>
<h4 id="类和对象的关系">类和对象的关系</h4>
<blockquote>
<p>类：是对现实生活中一类具有共同属性和行为的事物的抽象</p>
<p>对象：是能够看得到摸得着的真实存在的实体</p>
</blockquote>
<h4 id="类的定义">类的定义</h4>
<ul>
<li>
<p>类的重要性</p>
<blockquote>
<p>类是Java程序的基本组成单位</p>
</blockquote>
</li>
<li>
<p>类的组成</p>
<ul>
<li>
<p>属性</p>
<blockquote>
<p>在类中通过成员变量来体现（类中方法外的变量）</p>
</blockquote>
</li>
<li>
<p>行为</p>
<blockquote>
<p>在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="类的定义-2">类的定义</h4>
<figure data-type="image" tabindex="1"><img src="D:%5CSoftware%5CGridea%5Cdoc%5Cpost-images%5Cimage-20200821141416277.png" alt="类的定义" loading="lazy"></figure>
<h4 id="对象的使用">对象的使用</h4>
<figure data-type="image" tabindex="2"><img src="D:%5CSoftware%5CGridea%5Cdoc%5Cpost-images%5Cimage-20200821141923920.png" alt="对象的创建和使用" loading="lazy"></figure>
<h4 id="成员变量和局部变量的的区别">成员变量和局部变量的的区别</h4>
<table>
<thead>
<tr>
<th style="text-align:center">区别</th>
<th style="text-align:center">成员变量</th>
<th style="text-align:center">局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类中位置不同</td>
<td style="text-align:center">类中方法外</td>
<td style="text-align:center">方法内或者方法声明上（形参）</td>
</tr>
<tr>
<td style="text-align:center">内存中位置不同</td>
<td style="text-align:center">堆内存</td>
<td style="text-align:center">栈内存</td>
</tr>
<tr>
<td style="text-align:center">生命周期不同</td>
<td style="text-align:center">随着对象的存在而存在，随着对象的消失而消失</td>
<td style="text-align:center">随着方法的调用而存在，随着方法的调用结束而消失</td>
</tr>
<tr>
<td style="text-align:center">初始化值不同</td>
<td style="text-align:center">有默认的初始化值</td>
<td style="text-align:center">没有默认的初始化值，必须先定义赋值，才能使用</td>
</tr>
</tbody>
</table>
<h4 id="private关键字">private关键字</h4>
<ul>
<li>概述
<ul>
<li>是一个权限修饰符</li>
<li>可以修饰成员（成员变量和成员方法）</li>
<li>作用是保护成员不被别的类使用，被private修饰的成员只在本类中才能访问</li>
</ul>
</li>
<li>针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作
<ul>
<li>提供&quot;get变量名（）&quot;方法，用于获取成员变量的值，方法用public修饰</li>
<li>提供&quot;set变量名（参数）&quot;方法，用于设置成员变量的值，方法用public修饰</li>
</ul>
</li>
</ul>
<h4 id="封装">封装</h4>
<ul>
<li>
<p>封装概述</p>
<ul>
<li>封装是面向对象三大特征之一（封装、继承、多态）</li>
<li>封装是面向对象编程语言对客观世界的模拟，客观世界里的成员变量都是隐藏在对象内部的，外界是无法直接操作的。</li>
</ul>
</li>
<li>
<p>封装的原则</p>
<ul>
<li>
<p>将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</p>
<blockquote>
<p>成员变量用private进行修饰，提供对象的getXxx()/setXxx()方法</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>封装的好处</p>
<ul>
<li>通过方法来控制成员变量的操作，提高了代码的安全性</li>
<li>把代码用方法进行封装，提高了代码的复用性</li>
</ul>
</li>
</ul>
<h4 id="构造方法">构造方法</h4>
<blockquote>
<p>构造方法是一种特殊的方法</p>
<p>作用：创建对象</p>
<p>格式：<code>public class 类名{</code></p>
<p><code>修饰符 类名(参数){}</code></p>
<p><code>}</code></p>
<p>功能：主要是完成对象数据的初始化</p>
</blockquote>
<ul>
<li>
<p>构造方法的注意事项</p>
<ul>
<li>
<p>构造方法的创建</p>
<ul>
<li>如果没有定义的构造方法，系统将给出一个默认的无参构造方法</li>
<li>如果定义了构造方法，系统将不再提供默认的构造方法</li>
</ul>
</li>
<li>
<p>构造方法的重载</p>
<ul>
<li>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数的构造方法</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[数组和方法]]></title>
        <id>https://HealerLu.github.io/post/lP1sW6h3n/</id>
        <link href="https://HealerLu.github.io/post/lP1sW6h3n/">
        </link>
        <updated>2020-08-21T05:22:44.000Z</updated>
        <content type="html"><![CDATA[<h4 id="数组概述">数组概述</h4>
<ul>
<li>数组（array）是一种用于存储多个相同类型数据的存储模型</li>
</ul>
<h4 id="数组的定义格式">数组的定义格式</h4>
<ul>
<li>
<p>格式一：</p>
<ul>
<li>
<p>数据类型[] 变量名</p>
<blockquote>
<p>int[] arr</p>
<p>定义了一个int类型的数组，数组名是arr</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>格式二：</p>
<ul>
<li>
<p>数据类型 变量名[]</p>
<blockquote>
<p>int arr[]</p>
<p>定义了一个int类型的变量，变量名是arr数组</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="数组初始化">数组初始化</h4>
<ul>
<li>
<p>数组初始化概述</p>
<ul>
<li>Java中的数组必须先初始化，然后才能使用</li>
<li>所谓初始化就是为数组中的数组元素分配内存空间，并为每个数组元素赋值</li>
</ul>
</li>
<li>
<p>数组初始化方式</p>
<ul>
<li>动态初始化</li>
<li>静态初始化</li>
</ul>
</li>
<li>
<p>动态初始化</p>
<ul>
<li>
<p>概念</p>
<ul>
<li>初始化时只制定数组长度，由系统为数组分配初始值</li>
</ul>
</li>
<li>
<p>初始化格式</p>
<ul>
<li>
<p>数据类型[] 变量名 = new 数据类型[数组长度]</p>
</li>
<li>
<blockquote>
<p>int[] arr = new int[3]</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>数组元素访问</p>
<ul>
<li>数组变量访问方式
<ul>
<li>格式：数组名</li>
</ul>
</li>
<li>数组内部保存的数据的访问方式
<ul>
<li>格式：数组名[索引]</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>静态初始化</p>
<ul>
<li>
<p>概念</p>
<ul>
<li>初始化时指定每个数组元素的初始值，由系统决定数组长度</li>
</ul>
</li>
<li>
<p>格式</p>
<ul>
<li>
<p>数据类型[] 变量名 = new 数据类型[]{数据1， 数据2， 数据3，......}</p>
</li>
<li>
<blockquote>
<p>int[] arr = new int[]{1, 2, 3};</p>
</blockquote>
</li>
<li>
<p>简化格式：数据类型[] 变量名 = {数据1， 数据2， 数据3，......};</p>
</li>
<li>
<blockquote>
<p>int[] arr = {1, 2, 3};</p>
</blockquote>
</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="方法">方法</h4>
<ul>
<li>
<p>概述</p>
<ul>
<li>
<p>方法(method)是将具有独立功能的代码块组织成为一个整体，使其具有特殊功能的代码集。</p>
<blockquote>
<p>方法必须先创建才可以使用，该过程称为方法定义</p>
<p>方法创建后并不是直接运行的，需要手动使用后才执行，该过程称为方法调用</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>方法的定义</p>
<ul>
<li>
<p>格式</p>
<p><code>public static void 方法名(){</code></p>
<p>​	// 方法体</p>
<p><code>}</code></p>
</li>
</ul>
</li>
<li>
<p>方法的调用</p>
<ul>
<li>
<p>格式</p>
<p><code>方法名()</code></p>
</li>
</ul>
</li>
<li>
<p>带参数方法的定义</p>
</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200820174025554.png" alt="带参数方法的定义" loading="lazy"></figure>
<ul>
<li>
<p>带参数方法的调用</p>
<figure data-type="image" tabindex="2"><img src="https://HealerLu.github.io/post-images/image-20200820174141436.png" alt="带参数方法的调用" loading="lazy"></figure>
</li>
<li>
<p>带返回值方法的定义</p>
<figure data-type="image" tabindex="3"><img src="https://HealerLu.github.io/post-images/image-20200821095402058.png" alt="带返回值方法的定义" loading="lazy"></figure>
</li>
<li>
<p>带返回值方法的调用</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://HealerLu.github.io/post-images/image-20200821095435570.png" alt="带返回值方法的调用" loading="lazy"></figure>
<h4 id="方法重载">方法重载</h4>
<ul>
<li>
<p>概述</p>
<blockquote>
<p>方法重载是指同一个类中定义的多个方法之间的关系，满足下列条件的多个方法相互构成重载</p>
</blockquote>
<ul>
<li>多个方法都在同一个类中</li>
<li>多个方法具有相同的方法名</li>
<li>多个方法的参数不相同（类型不同或者数量不同）</li>
</ul>
</li>
<li>
<p>方法重载特点</p>
<ul>
<li>重载仅对应方法的定义，与方法的调用无关，调用方式参考标准格式</li>
<li>重载仅针对同哟个类中方法的名称与参数进行识别，与返回值无关。换句话说就是不能通过返回值来判定两个方法是否相互构成重载</li>
</ul>
</li>
</ul>
<h4 id="方法参数传递">方法参数传递</h4>
<ul>
<li>
<p>基本类型</p>
<blockquote>
<p>对于基本数据类型的参数，形参的改变，不影响实参的值</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://HealerLu.github.io/post-images/image-20200821103223726.png" alt="对于基本数据类型的参数，形参的改变，不影响实参的值" loading="lazy"></figure>
<blockquote>
<p>输出都为100</p>
</blockquote>
</li>
<li>
<p>引用类型</p>
<blockquote>
<p>对于引用类型的参数，形参的改变，影响实参的值</p>
</blockquote>
<figure data-type="image" tabindex="6"><img src="https://HealerLu.github.io/post-images/image-20200821103954981.png" alt="对于引用类型的参数，形参的改变，影响实参的值" loading="lazy"></figure>
<blockquote>
<p>第一次输出20，第二次输出200</p>
</blockquote>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[算术运算符和分支语句]]></title>
        <id>https://HealerLu.github.io/post/suan-zhu-yun-suan-fu-he-fen-zhi-yu-ju/</id>
        <link href="https://HealerLu.github.io/post/suan-zhu-yun-suan-fu-he-fen-zhi-yu-ju/">
        </link>
        <updated>2020-08-20T07:32:51.000Z</updated>
        <content type="html"><![CDATA[<h3 id="算术运算符">算术运算符</h3>
<h4 id="运算符和表达式">运算符和表达式</h4>
<ol>
<li>
<p>运算符</p>
<blockquote>
<p>对常量或者变量进行操作的符号</p>
</blockquote>
</li>
<li>
<p>表达式</p>
<blockquote>
<p>用运算符把常量或者变量连接起来符合Java语法的式子。不同运算符链接的表达式体现的是不同类型的表达式。</p>
</blockquote>
</li>
</ol>
<h4 id="算术运算符-2">算术运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">作用</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">+</td>
<td style="text-align:center">加</td>
</tr>
<tr>
<td style="text-align:center">-</td>
<td style="text-align:center">减</td>
</tr>
<tr>
<td style="text-align:center">*</td>
<td style="text-align:center">乘</td>
</tr>
<tr>
<td style="text-align:center">/</td>
<td style="text-align:center">除</td>
</tr>
<tr>
<td style="text-align:center">%</td>
<td style="text-align:center">取余</td>
</tr>
</tbody>
</table>
<blockquote>
<p>整数相除只能得到整数，要想得到小数，必须有浮点数的参与</p>
</blockquote>
<h4 id="字符的操作">字符的“+”操作</h4>
<blockquote>
<p>是拿字符在计算机底层对应的数值来进行计算的</p>
<p>'A' ------&gt; 65         A-Z是连续的</p>
<p>'a' ------&gt; 97          a-z是连续的</p>
<p>'0' ------&gt; 48          0-9是连续的</p>
<p>算是表达式中包含多个基本数据类型的值的时候，整个算是表达式的类型会自动进行提升</p>
</blockquote>
<p><strong>提升规则</strong></p>
<ul>
<li>
<p>byte、short、char类型将被提升到int类型</p>
</li>
<li>
<p>整个表达式的类型自动提升到表达式中最高等级操作数同样的类型</p>
<blockquote>
<p>等级顺序：btye,short,char ----&gt; int ----&gt; long ----&gt; float ----&gt; double</p>
</blockquote>
</li>
</ul>
<h4 id="字符串的操作">字符串的“+”操作</h4>
<ul>
<li>当 &quot;+&quot; 操作出现字符串时，&quot;+&quot;是字符串的连接，而不是算术运算。</li>
<li>当 &quot;+&quot;  操作中出现了字符串，就是连接运算符，否则就是算术运算。当连续进行 &quot;+&quot;  操作时，则为从左到右依次执行。</li>
</ul>
<h4 id="赋值运算符">赋值运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">=</td>
<td style="text-align:center">赋值</td>
<td style="text-align:center">a = 10， 将10赋值给变量a</td>
</tr>
<tr>
<td style="text-align:center">+=</td>
<td style="text-align:center">加后赋值</td>
<td style="text-align:center">a += b，将 a + b 的值给a</td>
</tr>
<tr>
<td style="text-align:center">-=</td>
<td style="text-align:center">减后赋值</td>
<td style="text-align:center">a -= b，将 a - b 的值给a</td>
</tr>
<tr>
<td style="text-align:center">*=</td>
<td style="text-align:center">乘后赋值</td>
<td style="text-align:center">a *= b，将 a * b 的值给a</td>
</tr>
<tr>
<td style="text-align:center">/=</td>
<td style="text-align:center">除后赋值</td>
<td style="text-align:center">a /= b，将 a / b 的商给a</td>
</tr>
<tr>
<td style="text-align:center">%=</td>
<td style="text-align:center">取余后赋值</td>
<td style="text-align:center">a %= b，将 a / b 的余数给a</td>
</tr>
</tbody>
</table>
<blockquote>
<p>扩展的赋值运算符隐含了强制类型转换</p>
</blockquote>
<h4 id="自增自减运算符">自增自减运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">++</td>
<td style="text-align:center">自增</td>
<td style="text-align:center">变量的值加1</td>
</tr>
<tr>
<td style="text-align:center">--</td>
<td style="text-align:center">自减</td>
<td style="text-align:center">变量的值减1</td>
</tr>
</tbody>
</table>
<ul>
<li>++ 和 -- 既可以放在变量的后面，也可以放在变量的前面</li>
<li>单独使用的时候， ++ 和 -- 无论是放在变量的前面或者是后边，结果都是一样的</li>
<li>参与操作的时候，如果放在变量的后面，则会先拿变量参与操作，后拿变量做 ++ 或者 --</li>
<li>参与操作的时候，如果放在变量的前面，则会先拿变量做 ++ 或者 --，后拿变量参与操作</li>
</ul>
<h4 id="关系运算符">关系运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">==</td>
<td style="text-align:center">a == b，判断a和b的值是否相等，成立为true，不成立为false</td>
</tr>
<tr>
<td style="text-align:center">!=</td>
<td style="text-align:center">a != b，判断a和b的值是否不相等，成立为true，不成立为false</td>
</tr>
<tr>
<td style="text-align:center">&gt;</td>
<td style="text-align:center">a &gt; b，判断a是否大于b，成立为true，不成立为false</td>
</tr>
<tr>
<td style="text-align:center">&gt; =</td>
<td style="text-align:center">a &gt;= b，判断a是否大于等于b，成立为true，不成立为false</td>
</tr>
<tr>
<td style="text-align:center">&lt;</td>
<td style="text-align:center">a &lt; b，判断a是否小于b，成立为true，不成立为false</td>
</tr>
<tr>
<td style="text-align:center">&lt;=</td>
<td style="text-align:center">a &lt;= b，判断a是否小于等于b，成立为true，不成立为false</td>
</tr>
</tbody>
</table>
<h4 id="逻辑运算符">逻辑运算符</h4>
<ul>
<li>描述
<ul>
<li>逻辑运算符是用来连接关系表达式的运算符</li>
<li>逻辑运算符也可以直接连接布尔类型的常量或者变量</li>
</ul>
</li>
</ul>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;</td>
<td style="text-align:center">逻辑与</td>
<td style="text-align:center">a &amp; b，a和b都是true，结果为true，否则为false</td>
</tr>
<tr>
<td style="text-align:center">|</td>
<td style="text-align:center">逻辑或</td>
<td style="text-align:center">a | b，a和b都是false，结果为false，否则为true</td>
</tr>
<tr>
<td style="text-align:center">^</td>
<td style="text-align:center">逻辑异或</td>
<td style="text-align:center">a ^ b，a和b结果不同为true，相同为false</td>
</tr>
<tr>
<td style="text-align:center">!</td>
<td style="text-align:center">逻辑非</td>
<td style="text-align:center">!a，和a的结果相反</td>
</tr>
</tbody>
</table>
<h4 id="短路逻辑运算符">短路逻辑运算符</h4>
<table>
<thead>
<tr>
<th style="text-align:center">符号</th>
<th style="text-align:center">作用</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">&amp;&amp;</td>
<td style="text-align:center">短路与</td>
<td style="text-align:center">作用和 &amp; 相同，但是有短路效果</td>
</tr>
<tr>
<td style="text-align:center">||</td>
<td style="text-align:center">短路或</td>
<td style="text-align:center">作用和 | 相同，但是有短路效果</td>
</tr>
</tbody>
</table>
<ul>
<li>逻辑与 &amp;，无论左边真假，右边都要执行</li>
<li>短路与&amp;&amp;，如果左边为真，右边执行；如果左边为假，右边不执行</li>
<li>逻辑或 |，无论左边真假，右边都要执行</li>
<li>短路或||，如果左边为假，右边执行；如果左边为真，右边不执行</li>
</ul>
<h4 id="三元运算符">三元运算符</h4>
<ul>
<li>
<p>格式：关系表达式 ? 表达式1 : 表达式2；</p>
<blockquote>
<p>a &gt; b ? a : b</p>
</blockquote>
</li>
</ul>
<h3 id="分支语句">分支语句</h3>
<h4 id="流程控制语句">流程控制语句</h4>
<ul>
<li>分类
<ul>
<li>顺序结构</li>
<li>分支结构（if，switch）</li>
<li>循环结构（for，while， do...while）</li>
</ul>
</li>
</ul>
<h4 id="顺序结构">顺序结构</h4>
<ul>
<li>顺序结构是程序中最简单最基本的流程控制，没有特定的语法结构。按照代码的先后顺序依次执行，程序中大多数的代码都是这样执行的。</li>
</ul>
<h4 id="if语句">if语句</h4>
<ul>
<li>格式1</li>
</ul>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200820113920642.png" alt="if语句格式" loading="lazy"></figure>
<ul>
<li>执行流程</li>
</ul>
<figure data-type="image" tabindex="2"><img src="https://HealerLu.github.io/post-images/image-20200820114211748.png" alt="执行流程" loading="lazy"></figure>
<ul>
<li>
<p>格式2</p>
<figure data-type="image" tabindex="3"><img src="https://HealerLu.github.io/post-images/image-20200820114332238.png" alt="if语句格式2" loading="lazy"></figure>
</li>
<li>
<p>执行流程</p>
</li>
</ul>
<figure data-type="image" tabindex="4"><img src="https://HealerLu.github.io/post-images/image-20200820130128452.png" alt="执行流程" loading="lazy"></figure>
<ul>
<li>
<p>格式3</p>
<figure data-type="image" tabindex="5"><img src="https://HealerLu.github.io/post-images/image-20200820130510602.png" alt="格式三" loading="lazy"></figure>
</li>
<li>
<p>执行流程</p>
</li>
</ul>
<figure data-type="image" tabindex="6"><img src="https://HealerLu.github.io/post-images/image-20200820130833146.png" alt="执行流程" loading="lazy"></figure>
<h4 id="switch语句">switch语句</h4>
<ul>
<li>
<p>格式</p>
<figure data-type="image" tabindex="7"><img src="https://HealerLu.github.io/post-images/image-20200820131531961.png" alt="switch" loading="lazy"></figure>
</li>
<li>
<p>流程</p>
<figure data-type="image" tabindex="8"><img src="https://HealerLu.github.io/post-images/image-20200820131619765.png" alt="流程" loading="lazy"></figure>
<blockquote>
<p>在switch与剧中，如果case控制的语句体后面不写break，将出现穿透现象；在不判断下一个case值得情况下，向下运行知道遇到break，或者整体switch语句结束。</p>
</blockquote>
</li>
</ul>
<h3 id="循环语句">循环语句</h3>
<ul>
<li>循环结构的组成
<ul>
<li>初始化语句： 用于表示循环开启时的起始状态，简单说就是循环开始的时候什么样</li>
<li>条件判断语句：用于表示循环反复执行的条件，简单说就是判断循环是否能一直执行下去</li>
<li>循环体语句： 用于表示循环反复执行的内容，简单说就是循环反复执行的事情</li>
<li>条件控制语句：用于表示循环执行中每次变化的内容，简单说就是控制循环是否能执行下去</li>
</ul>
</li>
<li>循环结构对应的语法
<ul>
<li>初始化语句：这里可以是一条或者多条语句，这些语句可以完成一些初始化操作</li>
<li>循环体语句：这里条件判断语句：这里使用一个结果值为boolean类型的表达式，这个表达式能决定是否执行循环体。例如：a&lt;3 可以是任意语句，这些语句将反复执行</li>
<li>条件控制语句：这里通常是使用一条语句来改变变量的值，从而达到控制循环是否继续向下执行的效果。常见i++,i--这样的操作</li>
</ul>
</li>
</ul>
<h4 id="for循环语句">for循环语句</h4>
<figure data-type="image" tabindex="9"><img src="https://HealerLu.github.io/post-images/image-20200820134405907.png" alt="for循环" loading="lazy"></figure>
<h4 id="while循环语句">while循环语句</h4>
<figure data-type="image" tabindex="10"><img src="https://HealerLu.github.io/post-images/image-20200820143027037.png" alt="while循环语句" loading="lazy"></figure>
<h4 id="dowhile循环语句">do...while循环语句</h4>
<figure data-type="image" tabindex="11"><img src="https://HealerLu.github.io/post-images/image-20200820143526546.png" alt="do...while循环语句" loading="lazy"></figure>
<h4 id="三种循环的区别">三种循环的区别</h4>
<ul>
<li>for循环和while循环先判断条件是否成立，然后决定是否执行循环体（先判断后执行）</li>
<li>do...while循环先执行一次循环体，然后判断条件是否成立，是否继续执行循环体（先执行后判断）</li>
</ul>
<h4 id="for和while的区别">for和while的区别</h4>
<ul>
<li>条件控制语句所控制的自增变量，因为归属for循环的语法结构中，在for循环结束后，就不能再次被访问到了</li>
<li>条件控制语句所控制的自增变量，对于while循环来说不归属其语法结构中，在while循环结束后，该变量还可以继续使用</li>
</ul>
<h4 id="条件控制语句">条件控制语句</h4>
<ul>
<li>概述
<ul>
<li>continue	用在循环中，基于条件控制，跳过某次循环体内容的执行，继续下一次的执行</li>
<li>break	用在循环中，基于条件控制，终止循环体内容的执行，也就是说结束当前的整个循环</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Java SE 基础]]></title>
        <id>https://HealerLu.github.io/post/java-se-ji-chu-jdk-de-an-zhuang/</id>
        <link href="https://HealerLu.github.io/post/java-se-ji-chu-jdk-de-an-zhuang/">
        </link>
        <updated>2020-08-19T05:15:13.000Z</updated>
        <content type="html"><![CDATA[<h4 id="jre-和-jdk">JRE 和 JDK</h4>
<ul>
<li>
<p><strong>JRE(Java Runtime Environment)</strong> 是Java程序的运行时环境，包含<strong>JVM</strong>和运行时所需要的核心类库</p>
<blockquote>
<p>我们想要运行一个已有的Java程序，那么只需要安装<strong>JRE</strong>即可</p>
</blockquote>
</li>
<li>
<p><strong>JDK（Java Development Kit ）<strong>是Java程序开发工具包，包含</strong>JVM</strong>和开发人员使用的工具</p>
<blockquote>
<p>其中的开发工具：编译工具（<strong>javac.exe</strong>）和运行工具（<strong>java.exe</strong>）</p>
</blockquote>
</li>
</ul>
<h4 id="jdk-jre和jvm的关系">JDK、JRE和JVM的关系</h4>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200819105356024.png" alt="JDK、JRE和JVM的关系" loading="lazy"></figure>
<h4 id="jdk的安装目录说明">JDK的安装目录说明</h4>
<figure data-type="image" tabindex="2"><img src="https://HealerLu.github.io/post-images/image-20200819110627110.png" alt="JDK的安装目录说明" loading="lazy"></figure>
<h4 id="关键字">关键字</h4>
<ol>
<li>概述
<ul>
<li>关键字就是被Java语言赋予了特定含义的单词</li>
</ul>
</li>
<li>特点
<ul>
<li>关键字的字母全部小写</li>
<li>常用的代码编辑器，针对关键字有特殊的颜色标记，非常直观</li>
</ul>
</li>
</ol>
<h4 id="常量">常量</h4>
<ol>
<li>
<p>概述</p>
<ul>
<li>在程序运行过程中，其值不可以发生改变的量</li>
</ul>
</li>
<li>
<p>分类</p>
<table>
<thead>
<tr>
<th style="text-align:center">常量类型</th>
<th style="text-align:center">说明</th>
<th style="text-align:center">举例</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">字符串常量</td>
<td style="text-align:center">用双引号括起来的内容</td>
<td style="text-align:center">&quot;Hello word&quot;</td>
</tr>
<tr>
<td style="text-align:center">整数常量</td>
<td style="text-align:center">不带小数的数字</td>
<td style="text-align:center">100，-88</td>
</tr>
<tr>
<td style="text-align:center">小数常量</td>
<td style="text-align:center">带小数的数字</td>
<td style="text-align:center">13.14，-2.22</td>
</tr>
<tr>
<td style="text-align:center">字符常量</td>
<td style="text-align:center">用单引号括起来的内容</td>
<td style="text-align:center">'A'，'0'</td>
</tr>
<tr>
<td style="text-align:center">布尔常量</td>
<td style="text-align:center">布尔值，表示真假</td>
<td style="text-align:center">只有两个值：true，false</td>
</tr>
<tr>
<td style="text-align:center">空常量</td>
<td style="text-align:center">一个特殊的值，空值</td>
<td style="text-align:center">null</td>
</tr>
</tbody>
</table>
<p>`public class HelloWord {</p>
<pre><code>public static void main (String[] args) {
 // 字符串常量
     System.out.println(&quot;hello word&quot;);
     System.out.println(&quot;--------&quot;);
 // 整数常量
     System.out.println(60);
     System.out.println(&quot;--------&quot;);
 //小数常量
     System.out.println(13.14);
     System.out.println(&quot;--------&quot;);
 // 字符常量
     System.out.println('A');
     System.out.println(&quot;--------&quot;);
 // 布尔常量
     System.out.println(true);
     System.out.println(&quot;--------&quot;);
 // 空常量
 // 空常量是不能直接输出的
     System.out.println(null);
}
</code></pre>
<p>}`</p>
</li>
</ol>
<h4 id="数据类型">数据类型</h4>
<ol>
<li>
<p>计算机存储单元</p>
<ul>
<li>
<p>无论是内存还是硬盘，计算机存储设备的最小信息单元叫<strong>位（bit）</strong>，我们又称之为<strong>比特位</strong>，通常用小写字母<strong>b</strong>表示。而计算机中最小的存储单元叫<strong>字节（byte）</strong>，通常用大写字母<strong>B</strong>表示，字节是由连续的8个位组成</p>
<blockquote>
<p>1B（字节） = 8bit</p>
<p>1KB = 1024B</p>
<p>1MB = 1024KB</p>
<p>1GB = 1024MB</p>
<p>1TB = 1024GB</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>数据类型</p>
<ul>
<li>Java语言是强类型语言，对于每一种数据都给出了明确的数据类型。不同的数据类型也分配了不同的内存空间，所以他们标识的数据大小也是不一样的。</li>
<li>数据类型的分类</li>
</ul>
<figure data-type="image" tabindex="3"><img src="https://HealerLu.github.io/post-images/image-20200819135847353.png" alt="数据类型" loading="lazy"></figure>
</li>
<li>
<p>数据类型内存占用和取值范围</p>
<figure data-type="image" tabindex="4"><img src="https://HealerLu.github.io/post-images/image-20200819140413077.png" alt="数据类型内存占用和取值范围" loading="lazy"></figure>
</li>
</ol>
<h4 id="变量">变量</h4>
<ol>
<li>
<p>变量概述</p>
<ul>
<li>在程序运行过程中，其值可以发生改变的量</li>
</ul>
</li>
<li>
<p>变量的定义</p>
<ul>
<li>
<p>格式： 数据类型 变量名 = 变量值；</p>
<blockquote>
<p><code>int a = 10;</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>变量的使用</p>
<ul>
<li>
<p>取值</p>
<ul>
<li>
<p>取值格式：变量名</p>
<blockquote>
<p><code>a</code></p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>修改值</p>
<ul>
<li>
<p>修改值格式： 变量名 = 变量值;</p>
<blockquote>
<p><code>a = 20</code></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p><code>public class HelloWord { public static void main (String[] args) { 		// 定义变量 		int a = 10; 		// 输出变量 		System.out.println(a); 		// 修改值 		a = 20; 		// 输出变量 		System.out.println(a); } }</code></p>
</li>
<li>
<p>声明变量的注意事项</p>
<ul>
<li>变量名字不能重复</li>
<li>变量未赋值不能使用</li>
<li><strong>long类型的变量名义的时候，为了防止整数过大，后面要加L</strong></li>
<li><strong>float类型的变量定义的时候为了防止类型不兼容，后面要加F</strong></li>
</ul>
</li>
</ol>
<h4 id="标识符">标识符</h4>
<ol>
<li>标识符概述
<ul>
<li>标识符就是给类、方法、变量等起名字的符号</li>
</ul>
</li>
<li>标识符的定义规则
<ul>
<li>由**数字、字母、下划线（_）和美元符（$）**组成</li>
<li>不能以数字开头</li>
<li>不能是关键字</li>
<li>区分大小写</li>
</ul>
</li>
<li>常见命名约定
<ul>
<li>小驼峰命名法：方法、变量
<ul>
<li>标识符是一个单词的时候，首字母小写</li>
<li>标识符由多个字母组成的时候，第一个单词字母小写，其余单词首字母大写</li>
</ul>
</li>
<li>大驼峰命名法：类
<ul>
<li>标识符是一个单词的时候，首字母大写</li>
<li>标识符由多个字母组成的时候每个单词首字母大写</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="类型转换">类型转换</h4>
<ol>
<li>
<p>类型转换分类</p>
<ul>
<li>
<p>自动类型转换</p>
<blockquote>
<p>把一个表示数据范围小地数值或者变量赋值给另一个表示数据范围大的变量</p>
</blockquote>
<figure data-type="image" tabindex="5"><img src="https://HealerLu.github.io/post-images/image-20200819143801886.png" alt="数据范围从小到大图" loading="lazy"></figure>
<blockquote>
<p><code>double d = 10</code></p>
</blockquote>
</li>
<li>
<p>强制类型转换（不建议使用）</p>
<blockquote>
<p>把一个表示数据范围大的数值或者变量赋值给另一个表示数据范围小的变量</p>
</blockquote>
<blockquote>
<p>格式： 目标数据类型 变量名 = （目标数据类型）值或者变量;</p>
<p><code>int k = (int)88.88 ==&gt; k为88</code></p>
</blockquote>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Mac终端如何使用代理]]></title>
        <id>https://HealerLu.github.io/post/mac-zhong-duan-ru-he-shi-yong-dai-li/</id>
        <link href="https://HealerLu.github.io/post/mac-zhong-duan-ru-he-shi-yong-dai-li/">
        </link>
        <updated>2020-08-17T02:05:46.000Z</updated>
        <content type="html"><![CDATA[<h3 id="在mac上安装使用shadowsocksx-ng-r8">在Mac上安装使用ShadowsocksX-NG-R8</h3>
<ol>
<li>
<p><a href="https://HealerLu.github.io/post-images/ShadowsocksX-NG-R8.dmg">点击下载ShadowsocksX-NG-R8.dmg</a></p>
</li>
<li>
<p>点击应用图标 ---&gt; HTTP代理设置 --&gt; 即可查看到监听的IP和端口号（一般为127.0.0.1:1087）</p>
</li>
</ol>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/1597629976115.png" alt="HTTP代理设置" loading="lazy"></figure>
<h3 id="使用iterm2终端设置代理">使用iterm2终端设置代理</h3>
<ol>
<li>
<p>打开终端输入<code>vim ~/.zshrc</code>进入vim</p>
</li>
<li>
<p>输入 `i进入编辑模式</p>
</li>
<li>
<p>输入以下命令设置终端代理</p>
</li>
</ol>
<p><code>alias goproxy='export http_proxy=http://127.0.0.1:1087 https_proxy=http://127.0.0.1:1087'</code><br>
<code>alias disproxy='unset http_proxy https_proxy'</code></p>
<p><em>注：alias为设置别名</em></p>
<ol start="4">
<li>
<p>按下<code>esc</code>退出编辑模式，再按下<code>:wq</code>退出vim并保存</p>
</li>
<li>
<p>使用<code>source ~/.zshrc</code>命令更新刚才编辑的内容</p>
</li>
<li>
<p>直接在命令行运行<code>goproxy</code>即可启动终端代理</p>
</li>
<li>
<p>运行<code>crul cip.cc</code>，输出的内容为代理服务器的IP时，即为设置成功，如下所示</p>
<p>`IP	: 128.22.126.241<br>
地址	: 日本  大阪府  大阪<br>
运营商	: k-opti.com</p>
<p>数据二	: 日本 | 大阪K Opti通讯</p>
<p>数据三	:</p>
<p>URL	: http://www.cip.cc/128.22.126.241`</p>
</li>
<li>
<p>如果想关闭代理，运行<code>disproxy</code>即可</p>
</li>
</ol>
]]></content>
    </entry>
</feed>