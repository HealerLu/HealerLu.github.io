<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://HealerLu.github.io</id>
    <title>Healer</title>
    <updated>2020-09-23T07:42:09.109Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://HealerLu.github.io"/>
    <link rel="self" href="https://HealerLu.github.io/atom.xml"/>
    <subtitle>&lt;strong&gt; 岁月不堪数，故人不如初&lt;/strong&gt;</subtitle>
    <logo>https://HealerLu.github.io/images/avatar.png</logo>
    <icon>https://HealerLu.github.io/favicon.ico</icon>
    <rights>All rights reserved 2020, Healer</rights>
    <entry>
        <title type="html"><![CDATA[函数式接口&&Stream流]]></title>
        <id>https://HealerLu.github.io/post/ZqV4DChEz/</id>
        <link href="https://HealerLu.github.io/post/ZqV4DChEz/">
        </link>
        <updated>2020-09-23T07:41:08.000Z</updated>
        <content type="html"><![CDATA[<h3 id="函数式接口概述">函数式接口概述</h3>
<ul>
<li>函数式接口：有且仅有一个抽象方法的接口</li>
<li>Java中的函数式编程体现就是Lambda表达式，所以函数式接口就是可以适用于Lambda使用的接口。只有确保接口中有且仅有一个抽象方法，Java中的Lambda才能顺利进行推导。</li>
<li>函数式接口的注解：<code>@FunctionalInterface</code></li>
</ul>
<h3 id="函数式接口的使用">函数式接口的使用</h3>
<ul>
<li>如果方法的参数是一个函数式接口，则可以使用Lambda表达式作为参数传递</li>
<li>如果方法的返回值是一个函数式接口，则可以使用Lambda表达式作为结果返回</li>
</ul>
<h3 id="常用的函数式接口">常用的函数式接口</h3>
<h4 id="supplier接口">Supplier接口</h4>
<h5 id="概述">概述</h5>
<ul>
<li>Supplier<T>：报好感一个无参的方法</li>
<li>T get()：获得结果</li>
<li>该方法不需要参数，它会按照某种实现逻辑(由Lambda表达式实现)返回一个数据</li>
<li>Supplier<T>接口也被称为生产型接口，如果我们指定了接口的泛型是什么类型，那么接口中的get()方法就会生产什么类型的数据供我们使用</li>
</ul>
<h5 id="使用">使用</h5>
<pre><code class="language-java">public static void main(String[] args) {
    String s = getString(() -&gt; &quot;哈哈哈&quot;);

    System.out.println(s);

}

private static String getString(Supplier&lt;String&gt; sup) {
    return sup.get();
}
</code></pre>
<h4 id="consumer接口">Consumer接口</h4>
<h5 id="概述-2">概述</h5>
<blockquote>
<p>Consumer<T>：包含两个方法</p>
</blockquote>
<ul>
<li>void accept(T t)：对给定的参数执行此操作</li>
<li>default Consumer<T> add(Consumer after)：返回一个组合的Consumer，一次执行此操作，然后执行after操作</li>
<li>Consumer<T>接口也被称为消费型接口，他消费的数据类型由泛型指定</li>
</ul>
<h4 id="predicate接口">Predicate接口</h4>
<blockquote>
<p>predicate<T>：常用的四个方法</p>
</blockquote>
<ul>
<li>boolean test(T t)：对给定得参数进行判断（判断的逻辑是由Lambda表达式实现），返回一个布尔值</li>
<li>default Predicate<T> negate()：返回一个逻辑得否定，对应逻辑非</li>
<li>default Predicate<T> and (Predicate other)：返回一个组合判断，对应短路与</li>
<li>default Predicate<T> or(Predicate other)：返回一个组合判断，对应短路或</li>
<li>Predicate<T>接口通常用于判断参数是否满足指定的条件</li>
</ul>
<h4 id="function接口">Function接口</h4>
<blockquote>
<p>Function&lt;T, R&gt;：常用的两个方法</p>
</blockquote>
<ul>
<li>R apply(T, t)：将此函数应用于给定的参数</li>
<li>default<V> Function adnThen(Function after)：返回一个组合函数，首席按将该函数应用于输入，然后将after函数应用等于结果。</li>
<li>Function&lt;T, R&gt;接口通常用于对参数进行处理码转换处理逻辑由Lambda表达式实现，然后返回一个新的值</li>
</ul>
<h3 id="stream流">Stream流</h3>
<h4 id="stream流的生成方式">Stream流的生成方式</h4>
<h5 id="stream流的使用">Stream流的使用</h5>
<ul>
<li>生成流
<ul>
<li>通过数据源（集合，数组等）生成流</li>
<li>list.stream()</li>
</ul>
</li>
<li>中间操作
<ul>
<li>一个流后面可以跟随零个或者多个中间操作，其主要是打开流，做出某种程度的数据过滤/映射，然后返回一个新的流，较给下一个操作使用。</li>
</ul>
</li>
<li>终结操作
<ul>
<li>一个流只能有一个终结操作，当这个操作执行后，流就被使用“光”了，无法再被操作。所以这必定是流的最后一个操作。</li>
</ul>
</li>
</ul>
<h4 id="stream流的生成方式-2">Stream流的生成方式</h4>
<blockquote>
<p>Stream流的常见生成方式</p>
</blockquote>
<ul>
<li>Collection体系的集合可以使用默认方法stream()生成流
<ul>
<li>default Stream<E> stream()</li>
</ul>
</li>
<li>Map体系的集合间接的生成流</li>
<li>数组可以通过Stream接口的静态方法of(T... values)生成流</li>
</ul>
<h4 id="stream流的常见中间操作方法">Stream流的常见中间操作方法</h4>
<ul>
<li>Stream<T> filter(Predicate predicate)：用于对流中的数据进行过滤
<ul>
<li>Predicate接口中的方法    boolean test(T t)：对给定的参数进行判断，返回一个布尔值</li>
</ul>
</li>
<li>Stream<T> limit(long maxSize)：返回此流中的元素组成的流，截取前指定参数个数的数据</li>
<li>Stream<T> skip(long n)：跳过指定参数个数的数据，返回由该流的剩余元素组成的流</li>
<li>static<T> Stream<T> contant(Stream a, Stream b)：合并a、b两个流为一个流</li>
<li>Stream<T> distinct()：返回由该留的不同元素(根据Object.equals(Object))组成的流</li>
<li>Stream<T> sorted()：返回由此流的元素组成的流，根据自然顺序排序</li>
<li>Stream<T> sorted(Comparator comparator)：返回由该流的元素组成的流，根据提供的Comparator 进行排序</li>
<li><R> Stream<R> map(Function mapper)：返回由给订函数应用于此流的元素的结果组成的流</li>
<li>IntStream mapToInt(ToIntFunction mapper)：返回一个IntStream其中包含将给定函数应用于此流的元素的结果
<ul>
<li>IntStream：表示原始int流</li>
<li>ToIntFunction 接口中的方法    int applyAsInt(T value)</li>
</ul>
</li>
</ul>
<h4 id="stream流的常见终结操作方法">Stream流的常见终结操作方法</h4>
<ul>
<li>void forEach(Consumer action)：对流的每个元素执行操作
<ul>
<li>Consumer接口中的方法  void accept(T t)：对给定的参数执行此操作</li>
</ul>
</li>
<li>long count()：返回此流中的元素数</li>
</ul>
<h4 id="stream流的收集操作">Stream流的收集操作</h4>
<blockquote>
<p>Stream流的收集方法</p>
</blockquote>
<ul>
<li>R collect(Collector collector)</li>
</ul>
<blockquote>
<p>工具类Collector提供了具体的收集方法</p>
</blockquote>
<ul>
<li>public static <T> Collector toList()：把元素收集到List集合中</li>
<li>public static <T> Collector toSet()：把元素收集到Set集合中</li>
<li>public static <T> Collector toMap(Function keyMapper, Function valueMapper)：把元素收集到Map集合中</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[Lambda表达式&&接口组成&&方法引用]]></title>
        <id>https://HealerLu.github.io/post/cgCdB15lv/</id>
        <link href="https://HealerLu.github.io/post/cgCdB15lv/">
        </link>
        <updated>2020-09-18T09:14:53.000Z</updated>
        <content type="html"><![CDATA[<h3 id="lambda表达式的格式">Lambda表达式的格式</h3>
<ul>
<li>(形式参数) -&gt; {代码块}
<ul>
<li>形式参数：如果有多个参数，参数之间用逗号隔开，如果没有参数，则留空</li>
<li>-&gt;：固定写法，代表指向动作</li>
<li>代码块：是我们具体要做的事情，也就是方法体内容</li>
</ul>
</li>
</ul>
<h3 id="lambda表达式的使用前提">Lambda表达式的使用前提</h3>
<ul>
<li>有一个接口</li>
<li>接口中有且仅有一个抽象方法</li>
</ul>
<h3 id="lambda表达式和匿名内部类的区别">Lambda表达式和匿名内部类的区别</h3>
<h4 id="所需类型不同">所需类型不同</h4>
<ul>
<li>匿名内部类：可以是接口，也可以是抽象类。还可以是具体类</li>
<li>Lambda表达式：只能是接口</li>
</ul>
<h4 id="使用限制不同">使用限制不同</h4>
<ul>
<li>如果接口中有且仅有一个抽象方法，可以使用Lambda表达式，也可以使用匿名内部类</li>
<li>如果接口中有多于一个抽象方法，则只能使用匿名内部类，而不能使用Lambda表达式</li>
</ul>
<h4 id="实现原理不同">实现原理不同</h4>
<ul>
<li>匿名内部类：编译之后，产生一个单独的.class字节码文件</li>
<li>Lambda表达式：编译之后，没有一个单独的.class字节码文件。对应的字节码会在运行的时候动态生成</li>
</ul>
<h3 id="接口组成更新">接口组成更新</h3>
<h4 id="接口组成更新概述">接口组成更新概述</h4>
<h5 id="接口的组成">接口的组成</h5>
<ul>
<li>常量（默认修饰符 <code>public static final</code>）</li>
<li>抽象方法(默认修饰符<code>public abstract</code>)</li>
<li>默认方法(Java8)</li>
<li>静态方法(java8)</li>
<li>私有方法(Java9)</li>
</ul>
<h5 id="接口的默认方法">接口的默认方法</h5>
<h6 id="定义格式">定义格式</h6>
<p><code>public default 返回值 方法名(参数列表){}</code></p>
<h6 id="注意事项">注意事项</h6>
<ul>
<li>默认方法不是抽象方法，所以不强制被重写。但是可以被重写。重写的时候去掉default关键字</li>
<li>public可以省略</li>
</ul>
<h5 id="接口的静态方法">接口的静态方法</h5>
<h6 id="定义格式-2">定义格式</h6>
<p><code>public static 返回值类型 方法名(参数列表){}</code></p>
<h6 id="注意事项-2">注意事项</h6>
<ul>
<li>静态方法只能通过接口名调用，不能通过实现类名或者对象名调用</li>
<li>public可以省略</li>
</ul>
<h5 id="接口的私有方法">接口的私有方法</h5>
<h6 id="定义格式-3">定义格式</h6>
<ul>
<li>格式一：<code>private 返回值类型 方法名(参数列表){}</code></li>
<li>格式二：<code>private static 返回值类型 方法名(参数列表){}</code></li>
</ul>
<h6 id="注意事项-3">注意事项</h6>
<ul>
<li>默认方法可以调用私有的静态方法和非静态方法</li>
<li>静态方法只能调用私有的静态方法</li>
</ul>
<h3 id="方法引用">方法引用</h3>
<h4 id="方法引用符">方法引用符</h4>
<ul>
<li><code>::</code>该符号为引用运算符，而它所在的表达式别成为方法引用</li>
</ul>
<h4 id="lambda表达式支持的方法引用">Lambda表达式支持的方法引用</h4>
<h5 id="常见的引用方法">常见的引用方法</h5>
<ul>
<li>引用类方法</li>
<li>引用对象的实例方法</li>
<li>引用类的实例方法</li>
<li>引用构造器</li>
</ul>
<h6 id="引用类方法">引用类方法</h6>
<blockquote>
<p>引用类方法，其实就是引用类的静态方法</p>
</blockquote>
<ul>
<li>格式：<code>类名::静态方法</code></li>
</ul>
<h6 id="引用对象的实例方法">引用对象的实例方法</h6>
<blockquote>
<p>引用对象的实例方法，其实就是引用类中的成员方法</p>
</blockquote>
<ul>
<li>格式：<code>对象::成员方法</code></li>
</ul>
<h6 id="引用类的实例方法">引用类的实例方法</h6>
<blockquote>
<p>引用类的实例方法，其实就是引用类中的成员方法</p>
</blockquote>
<ul>
<li>格式：<code>类名::成员方法</code></li>
</ul>
<h6 id="引用构造器">引用构造器</h6>
<blockquote>
<p>引用构造器，其实就是引用构造方法</p>
</blockquote>
<ul>
<li>格式：<code>类名::new</code></li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[网络编程]]></title>
        <id>https://HealerLu.github.io/post/fJWrPTvTz/</id>
        <link href="https://HealerLu.github.io/post/fJWrPTvTz/">
        </link>
        <updated>2020-09-18T05:58:38.000Z</updated>
        <content type="html"><![CDATA[<h3 id="网络编程">网络编程</h3>
<h4 id="网络编程概述">网络编程概述</h4>
<h5 id="计算机网络">计算机网络</h5>
<ul>
<li>是指将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路连接起来；在网络操作系统，网络管理软件及网络通讯协议的管理和协调下，实现资源共享和信息传递的计算机系统。</li>
</ul>
<h5 id="网络编程-2">网络编程</h5>
<ul>
<li>在网络通信协议下，实现网络互连的不同计算机上运行的程序可以进行数据交换。</li>
</ul>
<h4 id="网络编程三要素">网络编程三要素</h4>
<h5 id="ip地址">IP地址</h5>
<ul>
<li>要想让网络中的计算机能够互相通信，必须为每台计算机指定一个标识号，通过这个标识号来指定要接收数据的计算机和识别发送的计算机，而IP地址就是这个标识号。也就是设备的标识</li>
</ul>
<blockquote>
<p>IP地址是网络中设备的唯一标识</p>
</blockquote>
<h6 id="ip地址分为两大类">IP地址分为两大类</h6>
<ul>
<li>IPv4 ：是给每个连接在网络上的主机分配一个32bit地址。按照TCP/IP规定，IP地址用二进制来表示，每<br>
个IP地址长32bit，也就是4个字节。例如一个采用二进制形式的IP地址是“11000000 10101000<br>
00000001 01000010”，这么长的地址，处理起来也太费劲了。为了方便使用，IP地址经常被写成十进制<br>
的形式，中间使用符号“.”分隔不同的字节。于是，上面的IP地址可以表示为“192.168.1.66”。IP地址的这<br>
种表示法叫做“点分十进制表示法”，这显然比1和0容易记忆得多</li>
<li>IPv6 ：由于互联网的蓬勃发展，IP地址的需求量愈来愈大，但是网络地址资源有限，使得IP的分配越发<br>
紧张。为了扩大地址空间，通过IPv6重新定义地址空间，采用128位地址长度，每16个字节一组，分成8<br>
组十六进制数，这样就解决了网络地址资源数量不够的问题</li>
</ul>
<h6 id="dos常用命令">DOS常用命令</h6>
<ul>
<li>ipconfig ：查看本机IP地址</li>
<li>ping IP 地址：检查网络是否连通</li>
</ul>
<h6 id="特殊-ip地址">特殊 IP地址：</h6>
<ul>
<li>127.0.0.1 ：是回送地址，可以代表本机地址，一般用来测试使用</li>
</ul>
<h6 id="inetaddress">InetAddress</h6>
<blockquote>
<p>InetAddress：此类表示Internet协议（IP）地址</p>
</blockquote>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static InetAddress getbyName(String host)</td>
<td>确定主机名称的IP地址，主机名称可以是机器名称，也可以是IP地址</td>
</tr>
<tr>
<td>String getHostName()</td>
<td>获取此IP地址的主机名</td>
</tr>
<tr>
<td>String getHostAddress()</td>
<td>返回文本显示中的IP地址字符串</td>
</tr>
</tbody>
</table>
<h5 id="端口">端口</h5>
<blockquote>
<p>设备上应用程序的唯一标识</p>
</blockquote>
<ul>
<li>网络的通信，本质上是两个应用程序的通信。每台计算机都有很多的应用程序，那么在网络通信时，如何区分这些应用程序呢？如果说IP地址可以唯一标识网络中的设备，那么端口号就可以唯一标识设备中的应用程序了。也就是应用程序的标识</li>
</ul>
<h6 id="端口号">端口号</h6>
<ul>
<li>用两个字节表示的整数，它的取值范围是 0<sub>65535。其中，0</sub>1023之间的端口号用于一些知名的网络服<br>
务和应用，普通的应用程序需要使用1024以上的端口号。如果端口号被另外一个服务或应用所占用，会<br>
导致当前程序启动失败</li>
</ul>
<h5 id="协议">协议</h5>
<blockquote>
<p>计算机网络中，连接和通信的规则被称为网络通信协议</p>
</blockquote>
<ul>
<li>通过计算机网络可以使多台计算机实现连接，位于同一个网络中的计算机在进行连接和通信时需要遵守一定的规则，这就好比在道路中行驶的汽车一定要遵守交通规则一样。在计算机网络中，这些连接和通信的规则被称为网络通信协议，它对数据的传输格式、传输速率、传输步骤等做了统一规定，通信双方必须同时遵守才能完成数据交换。常见的协议有UDP协议和TCP协议</li>
</ul>
<h6 id="udp协议">UDP协议</h6>
<ul>
<li>用户数据报协议 (User Datagram Protocol)</li>
<li>UDP 是无连接通信协议，即在数据传输时，数据的发送端和接收端不建立逻辑连接。简单来说，当一台<br>
计算机向另外一台计算机发送数据时，发送端不会确认接收端是否存在，就会发出数据，同样接收端在<br>
收到数据时，也不会向发送端反馈是否收到数据。</li>
<li>由于使用 UDP协议消耗资源小，通信效率高，所以通常都会用于音频、视频和普通数据的传输</li>
<li>例如视频会议通常采用 UDP协议，因为这种情况即使偶尔丢失一两个数据包，也不会对接收结果产生太<br>
大影响。但是在使用UDP协议传送数据时，由于UDP的面向无连接性，不能保证数据的完整性，因此在<br>
传输重要数据时不建议使用UDP协议</li>
</ul>
<h6 id="tcp协议">TCP协议</h6>
<ul>
<li>传输控制协议 (Transmission Control Protocol)</li>
<li>TCP 协议是面向连接的通信协议，即传输数据之前，在发送端和接收端建立逻辑连接，然后再传输数<br>
据，它提供了两台计算机之间可靠无差错的数据传输。在TCP连接中必须要明确客户端与服务器端，由<br>
客户端向服务端发出连接请求，每次连接的创建都需要经过“三次握手”</li>
<li>三次握手： TCP协议中，在发送数据的准备阶段，客户端与服务器之间的三次交互，以保证连接的可靠
<ul>
<li>第一次握手，客户端向服务器端发出连接请求，等待服务器确认</li>
<li>第二次握手，服务器端向客户端回送一个响应，通知客户端收到了连接请求</li>
<li>第三次握手，客户端再次向服务器端发送确认信息，确认连接</li>
</ul>
</li>
<li>完成三次握手，连接建立后，客户端和服务器就可以开始进行数据传输了。由于这种面向连接的特性，<br>
TCP协议可以保证传输数据的安全，所以应用十分广泛。例如上传文件、下载文件、浏览网页等</li>
</ul>
<h3 id="udp通信程序">UDP通信程序</h3>
<blockquote>
<p>UDP协议是一种不可靠的网络协议，它在通信两端个建立了一个Socket对象，但是这两个Socket只是发送、接收数据的对象。因此对于基于UDP协议的通信双方而言，没有所谓的客户端和服务器的概念</p>
</blockquote>
<h4 id="udp发送数据">UDP发送数据</h4>
<h5 id="发送数据的步骤">发送数据的步骤</h5>
<ol>
<li>创建发送端的Socket对象(DatagramSocket)</li>
<li>创建数据，并把数据打包</li>
<li>调用DatagramSocket对象的方法发送数据</li>
<li>关闭发送端</li>
</ol>
<h5 id="示例">示例</h5>
<pre><code class="language-java">public class SendDemo {
  public static void main(String[] args) throws IOException {
    //创建发送端的Socket对象(DatagramSocket)
    // DatagramSocket() 构造数据报套接字并将其绑定到本地主机上的任何可用端口
    DatagramSocket ds = new DatagramSocket();
    //创建数据，并把数据打包
    //DatagramPacket(byte[] buf, int length, InetAddress address, int port)
    //构造一个数据包，发送长度为 length的数据包到指定主机上的指定端口号。
    byte[] bys = &quot;hello,udp,我来了&quot;.getBytes();
    DatagramPacket dp = new
DatagramPacket(bys,bys.length,InetAddress.getByName(&quot;192.168.120.66&quot;),10086);
    //调用DatagramSocket对象的方法发送数据
    //void send(DatagramPacket p) 从此套接字发送数据报包
    ds.send(dp);
    //关闭发送端
    //void close() 关闭此数据报套接字
    ds.close();
 }
}
</code></pre>
<h4 id="udp接收数据">UDP接收数据</h4>
<h5 id="接收数据的步骤">接收数据的步骤</h5>
<ol>
<li>创建接收端的Scoket对象(DatagramSocket)</li>
<li>创建一个数据包，用于接收数据</li>
<li>调用DatagramSocket对象的方法接收数据</li>
<li>解析数据包，并把数据在控制台显示</li>
<li>关闭接受端</li>
</ol>
<h5 id="示例-2">示例</h5>
<pre><code class="language-java">public class ReceiveDemo {
  public static void main(String[] args) throws IOException {
    //创建接收端的Socket对象(DatagramSocket)
    DatagramSocket ds = new DatagramSocket(12345);
    while (true) {
      //创建一个数据包，用于接收数据
      byte[] bys = new byte[1024];
      DatagramPacket dp = new DatagramPacket(bys, bys.length);
      //调用DatagramSocket对象的方法接收数据
      ds.receive(dp);
      //解析数据包，并把数据在控制台显示
      System.out.println(&quot;数据是：&quot; + new String(dp.getData(), 0,      
                dp.getLength()));
   }
 }
}
</code></pre>
<h3 id="tcp通信程序">TCP通信程序</h3>
<h4 id="tcp通信原理">TCP通信原理</h4>
<ul>
<li>TCP通信协议是一种可靠的网络协议，它再通信的两端个建立一个Socket对象，从而在通信的两端形成网络虚拟链路。一旦建立了虚拟的网络链路，两端的程序就可以通过虚拟链路进行通信。</li>
<li>Java 对基于TCP协议的的网络提供了良好的封装，使用Socket对象来代表两端的通信端口，并通过<br>
Socket产生IO流来进行网络通信。</li>
<li>Java 为客户端提供了Socket类，为服务器端提供了ServerSocket类</li>
</ul>
<h4 id="tcp发送数据">TCP发送数据</h4>
<h5 id="发送数据的步骤-2">发送数据的步骤</h5>
<ol>
<li>
<p>创建客户端的Socket对象(Socket)</p>
<ul>
<li>
<pre><code class="language-java">Socket(String host, int port);
</code></pre>
</li>
</ul>
</li>
<li>
<p>获取输出流，写数据</p>
<ul>
<li>
<pre><code class="language-java">OutputStream getOutputStream()
</code></pre>
</li>
</ul>
</li>
<li>
<p>释放资源</p>
<ul>
<li>
<pre><code class="language-java">void close()
</code></pre>
</li>
</ul>
</li>
</ol>
<h4 id="tcp接收数据">TCP接收数据</h4>
<h5 id="接收数据的步骤-2">接收数据的步骤</h5>
<ol>
<li>
<p>创建服务器端的Socket对象(ServerSocket)</p>
<ul>
<li>
<pre><code class="language-java">ServerSocket(int port)
</code></pre>
</li>
</ul>
</li>
<li>
<p>监听客户端连接，返回一个Socket对象</p>
<ul>
<li>
<pre><code class="language-java">Socket accept()
</code></pre>
</li>
</ul>
</li>
<li>
<p>获取输入流，读数据，并把数据显示在控制台</p>
<ul>
<li>
<pre><code class="language-java">InputStream getInputStream()
</code></pre>
</li>
</ul>
</li>
<li>
<p>释放资源</p>
<ul>
<li>
<pre><code class="language-java">void close()
</code></pre>
</li>
</ul>
</li>
</ol>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多线程]]></title>
        <id>https://HealerLu.github.io/post/yz0_jex0Z/</id>
        <link href="https://HealerLu.github.io/post/yz0_jex0Z/">
        </link>
        <updated>2020-09-17T07:29:06.000Z</updated>
        <content type="html"><![CDATA[<h3 id="进程">进程</h3>
<p>进程是正在运行的程序</p>
<ul>
<li>是系统进行资源分配和调用的独立单位</li>
<li>每一个进程都有它自己的内存空间和系统资源</li>
</ul>
<h3 id="线程">线程</h3>
<p>线程是进程中的单个顺序控制流，是一条执行路径</p>
<ul>
<li>单线程：一个进程如果只有一条执行路径，则称为单线程程序</li>
<li>多线程：一个进程如果有多条执行路径，则称为多线程程序</li>
</ul>
<h3 id="多线程的实现方式">多线程的实现方式</h3>
<h4 id="方式一继承thread类">方式一：继承Thread类</h4>
<ul>
<li>定义一个类(MyThread) 继承 Thread类</li>
<li>在类(MyThread) 中重写run()方法</li>
<li>创建(MyThread) 类的对象</li>
<li>启动线程</li>
</ul>
<h4 id="方式二实现runnable接口">方式二：实现Runnable接口</h4>
<ul>
<li>定义一个类(MyRunnable)实现Runable接口</li>
<li>在(MyRunnable)类中重写run()方法</li>
<li>创建(MyRunnable)类的对象</li>
<li>创建Thread类的对象，把(MyRunnable)对象作为构造方法的参数</li>
<li>启动线程</li>
</ul>
<h6 id="为什么要重写run方法">为什么要重写run()方法</h6>
<ul>
<li>run()方法是用来封装被线程执行的代码</li>
</ul>
<h6 id="run方法和strat方法的区别">run()方法和strat()方法的区别</h6>
<ul>
<li>run()：封装线程执行的代码，直接调用。相当于普通方法的调用</li>
<li>start()：启动线程，然后由JVM调用此线程的run方法</li>
</ul>
<h6 id="相比继承thread类实现runnable接口的好处">相比继承Thread类，实现Runnable接口的好处</h6>
<ul>
<li>避免了Java单继承的局限性</li>
<li>适合多个相同程序的代码去处理同一个资源的情况，把线程和线程的代码、数据有效分离，较好的体现了面向对象的设计思想</li>
</ul>
<h4 id="设置和获取线程名称">设置和获取线程名称</h4>
<h5 id="thread类中设置和获取线程名称的方法">Thread类中设置和获取线程名称的方法</h5>
<ul>
<li>void setName(String name)：将此线程的名称更改为等于参数name</li>
<li>String getName()：返回此线程的名称</li>
<li>通过构造方法也可以设置线程名称</li>
</ul>
<h5 id="获取main方法所在的线程名称">获取main()方法所在的线程名称</h5>
<ul>
<li>public static Thread currentThread()：返回对当前正在执行的线程对象的引用</li>
</ul>
<h4 id="线程调度">线程调度</h4>
<h5 id="调度模型">调度模型</h5>
<ul>
<li>分时调度模型：所有县城轮流使用CPU的使用权，平均分配每个线程占用CPU的时间片</li>
<li>抢占式调度模型：优先让优先级高的线程使用CPU，如果线程的优先级相同，那么会随机选择一个；优先级较高的线程获取的CPU时间片相对多一些</li>
</ul>
<h5 id="thread类中设置和获取线程优先级的方法">Thread类中设置和获取线程优先级的方法</h5>
<ul>
<li>public final int getPriority()：返回此线程的优先级</li>
<li>public final void setPriority(int newPriority)：更改此线程的优先级
<ul>
<li>线程默认优先级是5</li>
<li>线程优先级的范围是1-10</li>
<li>线程优先级高仅仅表示线程获取的CPU时间片的几率高，但是要在次数比较多，或者多次运行的时候才能看到想要的效果</li>
</ul>
</li>
</ul>
<h4 id="线程控制">线程控制</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>static void sleep(long millis)</td>
<td>使当前正在执行的线程停留（暂停执行）指定的毫秒数</td>
</tr>
<tr>
<td>void join()</td>
<td>等待这个线程死亡</td>
</tr>
<tr>
<td>void setDaemon(boolean on)</td>
<td>将此线程标记为守护线程，当运行的线程都是守护线程时，Java虚拟机将退出</td>
</tr>
</tbody>
</table>
<h4 id="线程的生命周期">线程的生命周期</h4>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200917094334867.png" alt="image-20200917094334867" loading="lazy"></figure>
<h4 id="同步代码块">同步代码块</h4>
<blockquote>
<p>锁多条语句操作共享数据，可以使用同步代码块来实现</p>
</blockquote>
<ul>
<li>格式</li>
</ul>
<pre><code class="language-java">synchronized(任意对象){
    // 多条语句操作共享数据的代码
}
</code></pre>
<ul>
<li>synchronized(任意对象)：就相当于给代码加锁了，任意对象就可以看成是一把锁</li>
</ul>
<h6 id="同步的好处和弊端">同步的好处和弊端</h6>
<ul>
<li>好处：解决了多线程的数据安全问题</li>
<li>弊端：当线程很多时，因为每个县城都会去判断同步上的锁，这是很耗费资源的，无形中会降低程序的运行效率</li>
</ul>
<h4 id="同步方法">同步方法</h4>
<blockquote>
<p>同步方法就是把synchronized关键字加到方法上</p>
</blockquote>
<ul>
<li>格式</li>
</ul>
<pre><code class="language-java">synchronized 返回值类型 方法名(方法参数){}
</code></pre>
<ul>
<li>
<p>同步方法的锁的对象是<code>this</code></p>
</li>
<li>
<p>同步静态方法就是把synchronized关键字加到静态方法上</p>
<ul>
<li>格式</li>
</ul>
<pre><code class="language-java">修饰符 static synchronized 返回值类型 方法名(方法参数){}
</code></pre>
</li>
<li>
<p>同步静态方法的锁的对象是<code>类名.class</code></p>
</li>
</ul>
<h4 id="线程安全的类">线程安全的类</h4>
<h5 id="stringbuffer">StringBuffer</h5>
<ul>
<li>线程安全，可变的字符序列</li>
<li>从版本JDK5开始，被StringBuilder替代，通常应该使用StringBuilder类，因为它支持所有相同的操作。但他更快，因为他不执行同步</li>
</ul>
<h5 id="vector">Vector</h5>
<ul>
<li>从Java2平台v1.2开始，该类改进了List接口，使其成为Java Collections Framework的成员。与新的集合实现不同。Vector被同步。如果不需要线程安全的实现，建议使用ArrayList代替Vecyor。</li>
</ul>
<h5 id="hashtable">Hashtable</h5>
<ul>
<li>该类实现了一个哈希表，它将键映射到值，任何非null对象都可以用作键或者值</li>
<li>从Java2平台v1.2开始，该类进行了改进，实现了Map接口。使其成为Java Collections Frameword的成员。与新的集合实现不同，Hashtable被同步。如果不需要线程安全的实现，建议使用HashMap代替Hashtable。</li>
</ul>
<h4 id="lock锁">Lock锁</h4>
<blockquote>
<p>Lock实现提供比synchronized方法和语句可以获得更广泛的锁定操作</p>
</blockquote>
<h5 id="lock中提供了获得锁和释放锁的方法">Lock中提供了获得锁和释放锁的方法</h5>
<ul>
<li>void lock()：获得锁</li>
<li>void unlock()：释放锁</li>
</ul>
<blockquote>
<p>Lock是接口不能直接实例化，这里采用它的实现类ReentrantLock来实例化</p>
</blockquote>
<h5 id="reentrantlock的构造方法">ReentrantLock的构造方法</h5>
<ul>
<li>ReentrantLock()：创建一个ReentrantLock的实例</li>
</ul>
<h4 id="生产者消费者">生产者消费者</h4>
<h5 id="生产者消费者模式概述">生产者消费者模式概述</h5>
<p>生产者消费者模式是一个十分经典的多线程协作的模式。所谓生产者消费者问题，实际上主要包含了两类线程：</p>
<ul>
<li>一类是生产者线程用于生产数据</li>
<li>一类是消费者线程用于消费数据</li>
</ul>
<p>为了解耦生产者和消费者的关系，通常会采用共享的数据区域</p>
<ul>
<li>生产者生产数据之后直接放置在共享数据区中，并不需要关心消费着的行为</li>
<li>消费者只需要从共享数据区中去获取数据，并不需要关心生产者的行为</li>
</ul>
<blockquote>
<p>为了体现生产和消费过程中的等待和唤醒，Java再Object类中提供了几个方法</p>
</blockquote>
<h5 id="object类的等待和唤醒方法">Object类的等待和唤醒方法</h5>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void wait()</td>
<td>导致当前线程等待，知道另一个线程调用该对象的notify()方法或notifyAll()方法</td>
</tr>
<tr>
<td>void notify()</td>
<td>唤醒正在等待对象监视器的单个线程</td>
</tr>
<tr>
<td>void notifyAll()</td>
<td>唤醒正在等待对象监视器的所有线程</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[IO]]></title>
        <id>https://HealerLu.github.io/post/snHuB_DAz/</id>
        <link href="https://HealerLu.github.io/post/snHuB_DAz/">
        </link>
        <updated>2020-09-11T08:30:52.000Z</updated>
        <content type="html"><![CDATA[<h3 id="file">File</h3>
<h4 id="file类概述">File类概述</h4>
<blockquote>
<p>File是文件和目录路径名的抽象表示</p>
</blockquote>
<ul>
<li>文件和目录是可以通过File封装成对象的</li>
<li>对于File而言。其封装的并不是一个真正存在的文件，仅仅是一个路径名而已。它可以是存在的，也可以是不存在的。将来是要通过具体的操作把这个路径的内容转为具体存在的。</li>
</ul>
<h4 id="file类的构造方法">File类的构造方法</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">File(String pathname)</td>
<td style="text-align:center">通过将给定的路径名字符串转换为抽象路径名来创建新的File实例</td>
</tr>
<tr>
<td style="text-align:center">File(String parent, String child)</td>
<td style="text-align:center">从父路径名字符串和子路径名字符串创建新的File实例</td>
</tr>
<tr>
<td style="text-align:center">File(File parent, String child)</td>
<td style="text-align:center">从父抽象路径名和自路径名字符串创建新的File实例</td>
</tr>
</tbody>
</table>
<h4 id="file类创建功能">File类创建功能</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean createNewFile()</td>
<td style="text-align:center">当具有该名称的文件不存在时，创建一个由该抽象路径名命名的新空文件</td>
</tr>
<tr>
<td style="text-align:center">public boolean mkdir()</td>
<td style="text-align:center">创建由此抽象路径命名的目录</td>
</tr>
<tr>
<td style="text-align:center">public boolean mkdirs()</td>
<td style="text-align:center">创建由此抽象路径命名的目录，包括任何必须但不存在的父目录</td>
</tr>
</tbody>
</table>
<h5 id="file类的判断和获取功能">File类的判断和获取功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean isDirectory()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否为目录</td>
</tr>
<tr>
<td style="text-align:center">public boolean isFile()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否为文件</td>
</tr>
<tr>
<td style="text-align:center">public boolean exists()</td>
<td style="text-align:center">测试此抽象路径名表示的File是否存在</td>
</tr>
<tr>
<td style="text-align:center">public String getAbsoultePath()</td>
<td style="text-align:center">返回此抽象路径名的绝对路径名字符串</td>
</tr>
<tr>
<td style="text-align:center">public String getPath()</td>
<td style="text-align:center">将此抽象路径转换为路径名字符串</td>
</tr>
<tr>
<td style="text-align:center">public String getName()</td>
<td style="text-align:center">返回此抽线路径名表示的文件或目录的名称</td>
</tr>
<tr>
<td style="text-align:center">public String[] list()</td>
<td style="text-align:center">返回此抽象路径名标识的目录中的文件和目录的名称字符串数组</td>
</tr>
<tr>
<td style="text-align:center">public File[] listFiles()</td>
<td style="text-align:center">返回此抽象路径名表示的目录中的文件和目录的File对象数组</td>
</tr>
</tbody>
</table>
<h5 id="file类的删除功能">File类的删除功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public boolean delete()</td>
<td style="text-align:center">删除由此抽象路径名表示的文件或目录</td>
</tr>
</tbody>
</table>
<h3 id="字节流">字节流</h3>
<h4 id="io流概述和分类">IO流概述和分类</h4>
<h5 id="io流概述">IO流概述</h5>
<ul>
<li>IO：输入/输出(input/Output)</li>
<li>流：是一种抽象概念，是对数据传输的总成。也就是说数据在设备间的传输称为流，流的本质是数据传输。</li>
<li>IO流就是用来处理设备间数据传输问题的，常见的应用：我呢见赋值、文件上传、文件下载</li>
</ul>
<h5 id="分类">分类</h5>
<ul>
<li>
<p>按照数据的流向</p>
<ul>
<li>输入流：读数据</li>
<li>输出流：写数据</li>
</ul>
</li>
<li>
<p>按照数据类型分类</p>
<ul>
<li>字节流
<ul>
<li>字节输入流、字节输出流</li>
</ul>
</li>
<li>字符流
<ul>
<li>字符输入流、字符输出流</li>
</ul>
</li>
</ul>
<blockquote>
<p>一般来说是按照数据类型来分的</p>
</blockquote>
</li>
</ul>
<h5 id="字节流写数据">字节流写数据</h5>
<h6 id="字节流抽象基类">字节流抽象基类</h6>
<ul>
<li>InputStream：这个抽象类是表示字节输入流的所有类的超类</li>
<li>OutputStream：这个抽象类是表示字节输出流的所有类的超类</li>
</ul>
<h6 id="fileoutputstream文件输出流用于将数据写入file">FileOutputStream：文件输出流用于将数据写入file</h6>
<ul>
<li>FileOutputStream(String name)：创建文件输出流以指定的名称写入文件</li>
</ul>
<h6 id="使用字节输出流写数据的步骤">使用字节输出流写数据的步骤：</h6>
<ul>
<li>创建字节输出流对象（调用系统功能创建了文件，创建字节输出流对象，让字节输出流对象指向文件）</li>
<li>调用字节输出流对象的写数据方法</li>
<li>释放资源（关闭此文件输出流并释放与此流相关联的任何系统资源）</li>
</ul>
<h6 id="字节流写数据的方法">字节流写数据的方法</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void write(int b)</td>
<td style="text-align:center">将指定的字节写入此文件输出流<br />一次写一个字节数据</td>
</tr>
<tr>
<td style="text-align:center">void write(byte[] b)</td>
<td style="text-align:center">将b.lenght字节从指定得字节数组写入此文件输出流<br />一次写一个字节的数据</td>
</tr>
<tr>
<td style="text-align:center">void write(byte[] b, int off, int len)</td>
<td style="text-align:center">将len字节从指定的字节数组开始，从偏移量off开始写入此文件输出流<br />一次写一个字节数组的部分数据</td>
</tr>
</tbody>
</table>
<h6 id="字节流写数据实现换行">字节流写数据实现换行</h6>
<pre><code class="language-java">FileOutputStream fos = new FileOutputStream(&quot;fos.txt&quot;);

for (int i = 0; i &lt; 10; i ++) {
    fos.write(&quot;hello&quot;.getBytes());
    // 实现换行   windows：\r\n   linux：\n mac: \r
    fos.write(&quot;\r\n&quot;.getBytes());
}
// 释放资源
fos.close();
</code></pre>
<h6 id="字节流写数据实现追加写入">字节流写数据实现追加写入</h6>
<ul>
<li>public FileOutputStream(String name, boolean append)</li>
<li>创建文件输出流以指定的名称写入文件，如果第二个参数为true，则字节将写入文件的末尾而不是开头</li>
</ul>
<h6 id="字节流写数据加异常处理">字节流写数据加异常处理</h6>
<ul>
<li>finally：在异常处理时提供finally块来执行所有清除操作。比如IO流中的释放资源</li>
<li>特点：被finally控制的语句一定会执行，除非JVM退出</li>
</ul>
<pre><code class="language-java">try{
    // 可能出现异常的代码
}catch(异常类名 变量名) {
    // 异常的处理代码
} finally{
    // 执行所有的清楚操作
}
</code></pre>
<pre><code class="language-java">FileOutputStream fos = null;
        try {
            fos = new FileOutputStream(&quot;Z:\\test&quot;);
            fos.write(&quot;Hello&quot;.getBytes());
        } catch (IOException e) {
            e.printStackTrace();
        }finally {
            if (fos != null) {
                try {
                    fos.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
</code></pre>
<h5 id="字节缓冲流">字节缓冲流</h5>
<ul>
<li>BufferedOutputStream：该类实现缓冲输出流。通过设置这样的输出流，应用程序可以向底层输出流写入字节，而不必为写入的每个字节导致底层系统的调用</li>
<li>BufferedInputStream：创建BufferedInputStream将创建一个内部缓冲区数组。当从流中读取或跳过字节时，内部缓冲区将根据需要从包含的输入流中重新填充，一次很多字节</li>
</ul>
<h6 id="构造方法">构造方法</h6>
<ul>
<li>字节缓冲输出流：BufferedOutputStream(OutputStream out)</li>
<li>字节缓冲输入流：BufferedInputStream(InputStream in)</li>
<li>构造方法需要的是字节流而不是具体的文件或者路径，是因为字节缓冲流仅仅提供缓冲区域，而真正读写数据还得依靠基本的字节流对象进行操作</li>
</ul>
<h3 id="字符流">字符流</h3>
<h4 id="为什么会出现字符流">为什么会出现字符流</h4>
<blockquote>
<p>由于字节流操作中文不是特别的方便，所以Java就提供了字符流</p>
</blockquote>
<ul>
<li>字符流 = 字节流 + 编码表</li>
</ul>
<h4 id="字符串中的编码解码问题">字符串中的编码解码问题</h4>
<h5 id="相关方法">相关方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">byte[] getBytes()</td>
<td style="text-align:center">使用平台的默认字符集将该 String编码为一系列字节</td>
</tr>
<tr>
<td style="text-align:center">byte[] getBytes(String charsetName)</td>
<td style="text-align:center">使用指定的字符集将该 String编码为一系列字节</td>
</tr>
<tr>
<td style="text-align:center">String(byte[] bytes)</td>
<td style="text-align:center">使用平台的默认字符集解码指定的字节数组来创建字符串</td>
</tr>
<tr>
<td style="text-align:center">String(byte[] bytes, String charsetName)</td>
<td style="text-align:center">通过指定的字符集解码指定的字节数组来创建字符串</td>
</tr>
</tbody>
</table>
<h4 id="字符流中的编码解码问题">字符流中的编码解码问题</h4>
<h5 id="字符流抽象基类">字符流抽象基类</h5>
<ul>
<li>Reader：字符输入流的抽象类</li>
<li>Writer：字符输出流的抽象类</li>
</ul>
<h5 id="字符流中和编码解码问题相关的两个类">字符流中和编码解码问题相关的两个类</h5>
<ul>
<li>InputStreamReader     字符输入流</li>
<li>OutputStreamWriter    字符输出流</li>
</ul>
<h5 id="便捷转换类">便捷转换类</h5>
<ul>
<li>FileReader：用于读取字符文件的便捷类
<ul>
<li>File Reader(String fileName)</li>
</ul>
</li>
<li>FileWriter：用于写入字符文件的便捷类
<ul>
<li>FileWriter(String fileName)</li>
</ul>
</li>
</ul>
<h4 id="字符流写数据的5种方式">字符流写数据的5种方式</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void write(int c)</td>
<td style="text-align:center">写一个字符</td>
</tr>
<tr>
<td style="text-align:center">void write(char[] cbuf)</td>
<td style="text-align:center">写入一个字符数组</td>
</tr>
<tr>
<td style="text-align:center">void write(char[] cbuf, int off, int len)</td>
<td style="text-align:center">写入字符数组的一部分</td>
</tr>
<tr>
<td style="text-align:center">void write(String str)</td>
<td style="text-align:center">写一个字符串</td>
</tr>
<tr>
<td style="text-align:center">void write(String str, int off, int len)</td>
<td style="text-align:center">写一个字符串的一部分</td>
</tr>
</tbody>
</table>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">flush()</td>
<td style="text-align:center">刷新流，还可以继续写数据</td>
</tr>
<tr>
<td style="text-align:center">close()</td>
<td style="text-align:center">关闭流，释放资源，但是在关闭前会先刷新流。一旦关闭，就不能再写数据</td>
</tr>
</tbody>
</table>
<h4 id="字符流读数据的2种方式">字符流读数据的2种方式</h4>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">int read()</td>
<td style="text-align:center">一次读一个字符数据</td>
</tr>
<tr>
<td style="text-align:center">int read(char[] cbuf)</td>
<td style="text-align:center">一次读一个字符数组数据</td>
</tr>
</tbody>
</table>
<h4 id="字符缓冲流">字符缓冲流</h4>
<h5 id="字符缓冲流-2">字符缓冲流</h5>
<ul>
<li>BufferedWriter ：将文本写入字符输出流，缓冲字符，以提供单个字符，数组和字符串的高效写入，可<br>
以指定缓冲区大小，或者可以接受默认大小。默认值足够大，可用于大多数用途</li>
<li>BufferedReader ：从字符输入流读取文本，缓冲字符，以提供字符，数组和行的高效读取，可以指定缓<br>
冲区大小，或者可以使用默认大小。 默认值足够大，可用于大多数用途</li>
</ul>
<h5 id="构造方法-2">构造方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">BufferedWriter(Writer out)</td>
<td style="text-align:center">创建字符缓冲输出流对象</td>
</tr>
<tr>
<td style="text-align:center">BufferedReader(Reader in)</td>
<td style="text-align:center">创建字符缓冲输入流对象</td>
</tr>
</tbody>
</table>
<h4 id="字符缓冲流的特有功能">字符缓冲流的特有功能</h4>
<ul>
<li>BufferedWriter
<ul>
<li>void newLine()：写一行行分隔符，行分隔符字符串由系统属性定义</li>
</ul>
</li>
<li>BufferedReader:
<ul>
<li>public String readLine()：读一行文字。结果包含行的内容字符串，不包括任何行终止字符，如果流的结尾已经到达，则为null</li>
</ul>
</li>
</ul>
<h3 id="io流小结">IO流小结</h3>
<h5 id="字节流-2">字节流</h5>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200911154542655.png" alt="image-20200911154542655" loading="lazy"></figure>
<h5 id="字符流-2">字符流</h5>
<figure data-type="image" tabindex="2"><img src="https://HealerLu.github.io/post-images/image-20200911154617711.png" alt="image-20200911154617711" loading="lazy"></figure>
<h4 id="复制多级文件案例">复制多级文件案例</h4>
<pre><code class="language-java">public class CopyFolder {
    public static void main(String[] args) throws IOException {
        // 创建数据源File对象
        File srcFile = new File(&quot;数据源路径&quot;);
        // 创建目的地File对象
        File destFile = new File(&quot;目的地路径&quot;);

        copyFolder(srcFile, destFile);

    }
    // 文件夹的复制方法
    public static void copyFolder(File srcFile, File destFile) throws IOException {
        if (srcFile.isDirectory()) {
            String srcFileName = srcFile.getName();
            // 生成新的目录
            File newFolder = new File(destFile, srcFileName);
            if (!newFolder.exists()) {
                newFolder.mkdir();
            }
            // 获取数据源目录下的所有文件或者文件夹的数组
            File[] fileArray = srcFile.listFiles();
            // 遍历数组得到每一个File对象
            for(File file : fileArray) {
                // 把该file作为数据源File对象，递归调用复制文件夹的方法
                copyFolder(file, newFolder);
            }
        } else {
            // 说明是文件，直接复制
            File newFile = new File(destFile, srcFile.getName());
            copyFile(srcFile, newFile);
        }
    }
    // 字节流缓冲复制文件  try ... catch ... finally的方式处理异常
    /*public static void copyFile(File srcFile, File destFile) {
        BufferedInputStream bf = null;
        BufferedOutputStream bo = null;
        try {
            // 字节流缓冲输入方法
            bf = new BufferedInputStream(new FileInputStream(srcFile));
            // 字节流缓冲输出方法
            bo = new BufferedOutputStream(new FileOutputStream(destFile));

            byte[] bys = new byte[1024];
            int len;
            while ((len = bf.read(bys)) != -1) {
                bo.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        } finally {
            if (bf != null) {
                try {
                    bf.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
            if (bo != null) {
                try {
                    bo.close();
                } catch (IOException e) {
                    e.printStackTrace();
                }
            }
        }
    }*/
    // JDK7之后的改进方案，可以自动释放资源
    /*public static void copyFile(File srcFile, File destFile) {
        try(BufferedInputStream bf = new BufferedInputStream(new FileInputStream(srcFile));
            BufferedOutputStream bo = new BufferedOutputStream(new FileOutputStream(destFile));) {

            byte[] bys = new byte[1024];
            int len;
            while ((len = bf.read(bys)) != -1) {
                bo.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }*/
    // JDK9之后的改进方案
    public static void copyFile(File srcFile, File destFile) throws IOException {
        BufferedInputStream bf = new BufferedInputStream(new FileInputStream(srcFile));
        BufferedOutputStream bo = new BufferedOutputStream(new FileOutputStream(destFile));
        try(bf; bo) {
            byte[] bys = new byte[1024];
            int len;
            while ((len = bf.read(bys)) != -1) {
                bo.write(bys, 0, len);
            }
        } catch (IOException e) {
            e.printStackTrace();
        }
    }

}

</code></pre>
<h3 id="特殊操作流">特殊操作流</h3>
<h4 id="标准输入输出流">标准输入输出流</h4>
<h5 id="标准输入流">标准输入流</h5>
<blockquote>
<p>System类中有两个静态的成员变量：</p>
</blockquote>
<ul>
<li>public static final InputStream in：标准输入流。通常该流对应于键盘输入活由主机环境或用户指定的另一个输入源。</li>
<li>public static final printStream out：标准输出流。通常该流对应于显示输出或由主机环境或用户指定的另一个输出目标。</li>
</ul>
<blockquote>
<p>自己实现键盘录入数据：</p>
</blockquote>
<ul>
<li>
<pre><code class="language-java">BufferedReader brs = new BufferedReader(new InputStreamReader(System.in));
</code></pre>
</li>
</ul>
<blockquote>
<p>Java也直接提供了一个类实现键盘录入</p>
</blockquote>
<ul>
<li>
<pre><code class="language-java">Scanner sc = new Scanner(System.in);
</code></pre>
</li>
</ul>
<h5 id="标准输出流">标准输出流</h5>
<blockquote>
<p>输出语句的本质是一个标准输出流</p>
</blockquote>
<ul>
<li>printStream ps = System.out;</li>
<li>printStream类有的方法，System.out都可以使用</li>
</ul>
<h4 id="打印流">打印流</h4>
<h5 id="打印流分类">打印流分类：</h5>
<ul>
<li>字节打印流：PrintSteam</li>
<li>字符打印流：PrintWrite</li>
</ul>
<h5 id="打印流的特点">打印流的特点：</h5>
<ul>
<li>只负责输出数据，不负责读取数据</li>
<li>有自己的特有方法</li>
</ul>
<h5 id="字节打印流">字节打印流</h5>
<ul>
<li>PrintStream(String fileName)：使用指定的文件名创建新的打印流</li>
<li>使用继承父类的方法写数据，查看的时候会转码；使用自己特有的方法写出局，查看的数据原样输出</li>
</ul>
<h5 id="字符打印流">字符打印流</h5>
<blockquote>
<p>字符打印流PrintWriter的构造方法</p>
</blockquote>
<table>
<thead>
<tr>
<th style="text-align:left">方法名</th>
<th style="text-align:left">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:left">PrintWriter(String fileName)</td>
<td style="text-align:left">使用指定文件创建一个新的PrintWriter，而不需要自动执行刷新</td>
</tr>
<tr>
<td style="text-align:left">PrintWriter(Writer out, boolean autoFlush)</td>
<td style="text-align:left">创建一个新的PrinWriter<br />- out:字符输出流<br />- autoFlush：一个布尔值，如果为真，则printIn、printf或format方法将刷新输出缓冲区</td>
</tr>
</tbody>
</table>
<h4 id="对象序列化流">对象序列化流</h4>
<blockquote>
<p>对象序列化：就是将对象保存到磁盘中，或者在网络中串数对象</p>
<p>这种机制就是使用了一个字节序列表示一个对象，该字节序列包含：对象的类型、对象的数据和对象存储的属性等信息。字节序列写到文件之后，相当于文件中持久保存了一个对象的信息</p>
<p>反之，该字节序列还可以从文件中读取回来，重构对象，对他进行反序列化</p>
</blockquote>
<h5 id="对象序列化流和对象饭序列化流">对象序列化流和对象饭序列化流</h5>
<ul>
<li>对象序列化流：ObjectOutputStream</li>
<li>对象反序列化流：ObjectInputStream</li>
</ul>
<h6 id="对象序列化流-2">对象序列化流</h6>
<blockquote>
<p>ObjectOutputStream：将Java对象的原始数据类型和图形写入OutputStream，可以使用ObjectInputStream读取（重构）对象。可以通过使用流的文件来实现对象的持久存储。如果流是网络套接字流，则可以再另一个主机上或另一个进程中重构对象</p>
</blockquote>
<ul>
<li>构造方法
<ul>
<li>ObjectOutputStream(OutputStream out)：创建一个写入指定的OutputStream的ObjectOutputStream</li>
</ul>
</li>
<li>序列化对象方法
<ul>
<li>void writeObject(Object obj)：将指定的对象写入ObjectOutputStream</li>
</ul>
</li>
</ul>
<blockquote>
<p>一个对象想要被序列化，该对象所属的类必须实现Serializable接口</p>
<p>Serializable是一个标记接口，实现该接口，不需要重写任何方法</p>
</blockquote>
<ul>
<li>
<p>注意事项</p>
<ul>
<li>
<p>用对象序列化流序列化了一个对象后，修改对象所属的类文件后，出现了InvalidClassException</p>
<ul>
<li>
<p>给对象所属的类加一个serialVersionUID</p>
<ul>
<li>
<pre><code class="language-java">private static final long serialVersionUID = 42L
</code></pre>
</li>
</ul>
</li>
</ul>
</li>
<li>
<p>对象中的某个成员变量的值不想被序列化时，可以给成员变量添加<code>transient</code>关键字修饰，该关键字标记的成员变量不参与序列化过程</p>
</li>
</ul>
</li>
</ul>
<h6 id="对象反序列化流">对象反序列化流</h6>
<blockquote>
<p>ObjectInputStream：反序列化先前使用ObjectOutputStream编写的原始数据和对象</p>
</blockquote>
<ul>
<li>构造方法
<ul>
<li>ObjectInputStream(inputStream in)：创建从指定得InputStream读取的ObjectInputStream</li>
</ul>
</li>
<li>反序列化对象方法
<ul>
<li>ObjectreadObject()：从ObjectInputStream读取一个对象</li>
</ul>
</li>
</ul>
<h3 id="properties">Properties</h3>
<h4 id="properties概述">Properties概述</h4>
<ul>
<li>是一个Map体系的集合类</li>
<li>Properties可以保存到流中或从流中加载</li>
</ul>
<h4 id="properties作为集合特有的方法">Properties作为集合特有的方法</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>Object setProperty(String key, String value)</td>
<td>设置集合的键和值，都是String类型，底层调用Hashtable方法 put</td>
</tr>
<tr>
<td>String getProperty(String key)</td>
<td>使用此属性列表中指定的键搜索属性</td>
</tr>
<tr>
<td>Set<String> stringPropertyNames()</td>
<td>从该属性列表重返回一个不可修改的键集，其中键及其对应的值是字符串</td>
</tr>
</tbody>
</table>
<h4 id="properties和io流结合的方法">Properties和IO流结合的方法：</h4>
<table>
<thead>
<tr>
<th>方法名</th>
<th>说明</th>
</tr>
</thead>
<tbody>
<tr>
<td>void load(InputStream inStream)</td>
<td>从输入字节流读取属性列表（键和元素对）</td>
</tr>
<tr>
<td>void load(Reader reader)</td>
<td>从输入字符流读取属性列表（键和元素对）</td>
</tr>
<tr>
<td>void store(OutputStream out, String comments)</td>
<td>将此属性列表（键和元素对）写入此Properties表中，以适合于使用load(inputStream)方法的格式写入输出字节流</td>
</tr>
<tr>
<td>void store(Writer writer, String comments)</td>
<td>将此属性列表（键和元素对）写入此Properties表中，以适合使用load(Reader)方法的格式写入输出字符流</td>
</tr>
</tbody>
</table>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[集合]]></title>
        <id>https://HealerLu.github.io/post/f-4HJd9X2/</id>
        <link href="https://HealerLu.github.io/post/f-4HJd9X2/">
        </link>
        <updated>2020-09-09T06:58:09.000Z</updated>
        <content type="html"><![CDATA[<h4 id="集合类体系结构">集合类体系结构</h4>
<figure data-type="image" tabindex="1"><img src="https://HealerLu.github.io/post-images/image-20200902164026717.png" alt="image-20200902164026717" loading="lazy"></figure>
<h5 id="collection集合概述和使用">Collection集合概述和使用</h5>
<h6 id="概述">概述</h6>
<ul>
<li>Collection集合是单列集合的顶层接口，它表示一组对象，这些对象也称为Collection的元素</li>
<li>JDK不提供此接口的任何直接实现，它提供更具体的子接口（如Set和List）实现</li>
</ul>
<h5 id="创建collection集合的对象">创建Collection集合的对象</h5>
<ul>
<li>多态的方式</li>
<li>具体的实现类ArrayList</li>
</ul>
<blockquote>
<p><code>Collection&lt;String&gt; c = new ArrayList&lt;String &gt;();</code></p>
</blockquote>
<h5 id="collection集合常用方法">Collection集合常用方法</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">boolean add(E e)</td>
<td style="text-align:center">添加元素</td>
</tr>
<tr>
<td style="text-align:center">boolean remove(Object o)</td>
<td style="text-align:center">从几何中移除指定的元素</td>
</tr>
<tr>
<td style="text-align:center">void colear()</td>
<td style="text-align:center">清空集合中的元素</td>
</tr>
<tr>
<td style="text-align:center">boolean contains(Object 0)</td>
<td style="text-align:center">判断几何中是否存在指定的元素</td>
</tr>
<tr>
<td style="text-align:center">boolean isEmpty()</td>
<td style="text-align:center">判断集合是否为空</td>
</tr>
<tr>
<td style="text-align:center">int size()</td>
<td style="text-align:center">集合的长度，也就是集合中元素的个数</td>
</tr>
</tbody>
</table>
<h5 id="collection集合的遍历">Collection集合的遍历</h5>
<h6 id="iterator迭代器集合的专用遍历方式">Iterator：迭代器，集合的专用遍历方式</h6>
<ul>
<li>Iterator<E> iterator()：返回此几何中元素的迭代器，通过集合的iterator()方法得到</li>
<li>迭代器是通过集合的iterator()方法得到的，所以我们说他是抵赖于集合而存在的</li>
</ul>
<h6 id="iterator中常用的方法">Iterator中常用的方法</h6>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
</ul>
<pre><code class="language-java">// 创建集合对象
Collection&lt;String&gt; c = new ArrayList&lt;String&gt;();
// 向集合里面添加元素
c.add(&quot;Demo1&quot;);
c.add(&quot;Demo2&quot;);
c.add(&quot;Demo3&quot;);
c.add(&quot;Demo4&quot;);
// 创建迭代器
Iterator&lt;String&gt; it = c.iterator();
while (it.hasNext()) {
    String s = it.next();
    System.out.println(s);
}
</code></pre>
<h5 id="list集合概述和特点">List集合概述和特点</h5>
<h6 id="list集合概述">List集合概述</h6>
<ul>
<li>有序集合（也成为序列），用户可以景区控制列表中每个元素的插入位置，可以通过整数索引访问元素并搜索列表中的元素</li>
<li>与Set集合不同，列表通常允许重复的元素</li>
</ul>
<h6 id="list集合特点">List集合特点</h6>
<ul>
<li>
<p>有序：存储和取出的元素顺序一致</p>
</li>
<li>
<p>可重复：存储的元素可以重复</p>
<pre><code class="language-java">List&lt;String&gt; l = new ArrayList&lt;String&gt;();

l.add(&quot;1&quot;);
l.add(&quot;2&quot;);
l.add(&quot;3&quot;);
l.add(&quot;3&quot;);

//System.out.println(l); [1, 2, 3, 3]
// 迭代器方式遍历
Iterator&lt;String&gt; iterator = l.iterator();
while (iterator.hasNext()) {
    String s = iterator.next();
    System.out.println(s);
}
</code></pre>
</li>
</ul>
<h6 id="list集合的特有方法">List集合的特有方法</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">void add(int index, E element)</td>
<td style="text-align:center">在此几何中的指定位置插入指定的元素</td>
</tr>
<tr>
<td style="text-align:center">E remove(int index)</td>
<td style="text-align:center">删除指定索引处的元素，返回被删除的元素</td>
</tr>
<tr>
<td style="text-align:center">E set(int index, E element)</td>
<td style="text-align:center">修改指定索引处的元素，返回被修改的元素</td>
</tr>
<tr>
<td style="text-align:center">E get(int index)</td>
<td style="text-align:center">返回指定索引处的元素</td>
</tr>
</tbody>
</table>
<h6 id="listiterator">ListIterator</h6>
<blockquote>
<p>ListIterator：列表迭代器</p>
</blockquote>
<ul>
<li>通过List集合的listiterator()方法得到，所以说它是List集合特有的迭代器</li>
<li>用于允许程序沿任一方向遍历列表的列表迭代器，在迭代期间修改列表，并获取列表中迭代器的当前位置。</li>
</ul>
<blockquote>
<p>常用方法</p>
</blockquote>
<ul>
<li>E next()：返回迭代中的下一个元素</li>
<li>boolean hasNext()：如果迭代具有更多元素，则返回true</li>
<li>E previous()：返回列表重的上一个元素</li>
<li>boolean hasPrevious()：如果此列表迭代器在相反方向遍历列表时具有更多元素，则返回true</li>
<li>void add(E e)：将指定的元素插入列表</li>
</ul>
<pre><code class="language-java">List&lt;String&gt; list = new ArrayList&lt;&gt;();

list.add(&quot;1&quot;);
list.add(&quot;2&quot;);
list.add(&quot;3&quot;);
// 正向遍历
ListIterator&lt;String&gt; iterator = list.listIterator();
while (iterator.hasNext()) {
    System.out.println(iterator.next());
}
// 逆向遍历
while (iterator.hasPrevious()) {
    System.out.println(iterator.previous());
}
// 添加
while (iterator.hasNext()) {
    String s = iterator.next();
    if (s.equals(&quot;1&quot;)) {
        iterator.add(&quot;4&quot;);
    }
}
System.out.println(list);
</code></pre>
<h6 id="增强for循环">增强for循环</h6>
<blockquote>
<p>简化数组和Collection集合的遍历</p>
</blockquote>
<ul>
<li>实现Iterable接口的类允许其对象成为增强型for语句的目标</li>
<li>它是JDK5之后出现的，其内部原理是一个Iterator迭代器</li>
</ul>
<blockquote>
<p>增强for的格式</p>
</blockquote>
<pre><code class="language-java">for(元素数据类型 变量名:数组或者Collection集合){
    // 在此处使用变量即可，该变量就是元素
}
</code></pre>
<blockquote>
<p>范例</p>
</blockquote>
<pre><code class="language-java">int[] arr = {1, 2, 3, 4, 5};
for(int i : arr){
    System.out.println(i);
}
</code></pre>
<h6 id="list集合子类特点">List集合子类特点</h6>
<blockquote>
<p>list集合常用子类：ArrayList、LinkedList</p>
</blockquote>
<ul>
<li>ArrayList：底层数据结构是数组，查询快，增删慢</li>
<li>LinkedList：底层数据结构是链表，查询慢，增删快</li>
</ul>
<h6 id="linkedlist集合的特有功能">LinkedList集合的特有功能</h6>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">public void addFirst(E e)</td>
<td style="text-align:center">在该列表开头插入指定的元素</td>
</tr>
<tr>
<td style="text-align:center">public void addLast(E e)</td>
<td style="text-align:center">将指定的元素追加到此列表的末尾</td>
</tr>
<tr>
<td style="text-align:center">public void getFirst()</td>
<td style="text-align:center">返回此列表中的第一个元素</td>
</tr>
<tr>
<td style="text-align:center">public getLast()</td>
<td style="text-align:center">返回此列表重的最后一个元素</td>
</tr>
<tr>
<td style="text-align:center">public E removeFirst()</td>
<td style="text-align:center">从此列表中删除并返回第一个元素</td>
</tr>
<tr>
<td style="text-align:center">public E removeLast()</td>
<td style="text-align:center">从此列表中删除并返回最后一个元素</td>
</tr>
</tbody>
</table>
<h5 id="set集合">Set集合</h5>
<h6 id="set集合概述和特点">Set集合概述和特点</h6>
<ul>
<li>不包含重复元素的集合</li>
<li>没有带索引的方法，所以不能使用普通的for循环</li>
</ul>
<pre><code class="language-java">// 创建HashSet并遍历
Set&lt;Integer&gt; set = new HashSet&lt;&gt;();

set.add(1);
set.add(2);
set.add(3);

Iterator&lt;Integer&gt; it = set.iterator();
while (it.hasNext()) {
    System.out.println(it.next());
}
System.out.println(set);
</code></pre>
<h6 id="哈希值">哈希值</h6>
<blockquote>
<p>哈希值是JDK根据对象的地址或者字符串或者数字算出来的int类型的数值</p>
<p>Object类中的<code>public int hashCode()</code>方法可以返回对象的哈希码值</p>
</blockquote>
<blockquote>
<p>对象的哈希值特点</p>
</blockquote>
<ul>
<li>同一个对象多次调用hashCode()方法返回的哈希值是相同的</li>
<li>默认情况下，不同对象的哈希值是不同的。而重写hashCode()方法，可以实现让不同对象的哈希值相同</li>
</ul>
<h6 id="linkedhashset集合的概述和特点">LinkedHashSet集合的概述和特点</h6>
<ul>
<li>hash表和链表实现的Set接口，具有可预测的迭代次序</li>
<li>由链表保证元素有序，也就是说元素的存储和取出顺序是一致的</li>
<li>由哈希表保证元素唯一，也就是说没有重复的元素</li>
</ul>
<h6 id="treeset集合概述和特点">TreeSet集合概述和特点</h6>
<ul>
<li>元素有序，这里的顺序不是指存储和取出的顺序，而是按照一定的规则进行排序，具体排序方式取决于构造方法。
<ul>
<li>TreeSet()：根据元素的自然排序进行排序。</li>
<li>TreeSet(Comparator comparator)：根据指定的比较器进行排序。</li>
</ul>
</li>
<li>没有带索引的方法，所以不能使用普通for循环遍历</li>
<li>由于是Set集合，所以不包含重复元素</li>
</ul>
<h6 id="自然排序comparable的使用">自然排序Comparable的使用</h6>
<ul>
<li>用TreeSet集合存储自定义对象，无参构造方法使用的是自然排序对元素进行排序的</li>
<li>自然排序，就是让元素所属的类实现Comparable接口，重写compareTo(To)方法</li>
</ul>
<h6 id="比较器排序comparator的使用">比较器排序Comparator的使用</h6>
<ul>
<li>用TreeSet集合存储自定义对象，带参构造方法使用的是比较器排序对元素进行排序的</li>
<li>比较器排序就是让集合构造方法接收Comparator的实现类对象，重写compareTo(To1, To2)方法</li>
</ul>
<h4 id="泛型">泛型</h4>
<h5 id="泛型概述">泛型概述</h5>
<blockquote>
<p>泛型：是JDK5中引入的特性，它提供了编译时类型安全检测机制，该机制允许在编译时检测到非法的类型<br>
它的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。一提到参数，最熟悉的就是定义方<br>
法时有形参，然后调用此方法时传递实参。那么参数化类型怎么理解呢？顾名思义，就是将类型由原来的具<br>
体的类型参数化，然后在使用/调用时传入具体的类型。这种参数类型可以用在类、方法和接口中，分别被称<br>
为泛型类、泛型方法、泛型接口</p>
</blockquote>
<h5 id="泛型定义格式">泛型定义格式</h5>
<ul>
<li>&lt;类型&gt;：指定一种类型的格式。这里的类型可以看成是形参</li>
<li>&lt;类型1，类型2...&gt;：指定多种类型的格式，多种类型之间用逗号隔开。这里的类型可以看成是形参</li>
<li>将来具体调用的时候给定的类型可以看成是实参，并且实参的类型行只能是引用数据类型</li>
</ul>
<h5 id="泛型的好处">泛型的好处</h5>
<ul>
<li>把运行时期的问题提前到了编译期间</li>
<li>避免了强制类型转换</li>
</ul>
<h5 id="泛型类">泛型类</h5>
<h6 id="泛型类的定义格式">泛型类的定义格式</h6>
<ul>
<li>修饰符 class 类名 &lt;类型&gt; {}</li>
</ul>
<pre><code class="language-java">public class Demo&lt;T&gt;{
    // 此处T可以随便写为任意标识，常见的如T、E、K、V等形式的参数常用于表示泛型
}
</code></pre>
<h5 id="泛型方法">泛型方法</h5>
<h6 id="泛型方法的定义格式">泛型方法的定义格式</h6>
<ul>
<li>修饰符 &lt;类型&gt; 返回值类型 方法名(类型 变量名){}</li>
</ul>
<pre><code class="language-java">public &lt;T&gt; void show(T t){}
</code></pre>
<pre><code class="language-java">// 类
public class Generic{
    // 定义泛型方法
    public &lt;T&gt; void show(T t){
        System.out.println(t);
    }
}
// 使用
public static void main(String[] args) {
    Generic g = new Generic();
    g.show(30);
    g.show(&quot;张三&quot;);
}
</code></pre>
<h5 id="泛型接口">泛型接口</h5>
<h6 id="泛型接口的定义格式">泛型接口的定义格式</h6>
<ul>
<li>修饰符 interface 接口名 &lt;类型&gt; {}</li>
</ul>
<pre><code class="language-java">public interface Generic&lt;T&gt;{}
</code></pre>
<h5 id="类型通配符">类型通配符</h5>
<h6 id="类型通配符概述">类型通配符概述</h6>
<ul>
<li>为了表示各种泛型List的父类。可以使用类型通配符</li>
<li>类型通配符：&lt;?&gt;</li>
<li>List&lt;?&gt;：表示元素类型未知的List，它的元素可以匹配任何的类型</li>
<li>这种代通配符的List仅表示它是各种泛型List的父类，并不能把元素添加到其中</li>
</ul>
<blockquote>
<p>如果说我们不希望List&lt;?&gt;是任何泛型List的父类，只希望它代表某一类泛型List的父类，可以使用类型通配符的上限</p>
</blockquote>
<ul>
<li>
<p>类型通配符上限：&lt;? extends 类型&gt;</p>
</li>
<li>
<pre><code class="language-java">List&lt;? extends Number&gt; //表示的类型是Number或者其子类型
</code></pre>
</li>
</ul>
<blockquote>
<p>除了可以指定类型通配符的上限，我们也可以指定类型通配符的下限</p>
</blockquote>
<ul>
<li>
<p>类型通配符下限：&lt;? super 类型&gt;</p>
</li>
<li>
<pre><code class="language-java">List&lt;? super Number&gt; //表示的类型是Number或者其父类型
</code></pre>
</li>
</ul>
<h5 id="可变参数">可变参数</h5>
<h6 id="可变参数概述">可变参数概述</h6>
<ul>
<li>
<p>可变参数又称参数个数可变，用作方法的形参出现，那么方法参数的格式就是可变的了</p>
</li>
<li>
<p>格式：修饰符 返回值类型 方法名(数据类型... 变量名){}</p>
</li>
<li>
<pre><code class="language-java">public static int sun(int... a){}
</code></pre>
</li>
</ul>
<h6 id="可变参数的使用">可变参数的使用</h6>
<blockquote>
<p>Arrays工具类中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <T> List<T> asList(T... a)：返回由指定数组支持的固定大小的列表</li>
<li>返回的集合不能做增删操作，可以做修改操作</li>
</ul>
<blockquote>
<p>List接口中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <E> List <E> of (E... elements)：返回包含任意数量元素的不可变列表</li>
<li>返回的集合不能做增删改操作</li>
</ul>
<blockquote>
<p>Set接口中有一个静态方法</p>
</blockquote>
<ul>
<li>public static <E> Set <E> of (E... element)：返回一个包含任意数量元素的不可变集合</li>
<li>返回的集合不能做增删操作，没有修改的方法</li>
<li>再给元素的时候，不能给重复的元素</li>
</ul>
<h4 id="map集合">Map集合</h4>
<h5 id="map集合的概述和使用">Map集合的概述和使用</h5>
<ul>
<li>Interface Map&lt;K,V&gt;      K：键的类型      V：值的类型</li>
<li>将键映射到值得对象，不能包含重复的键，每个键可以映射到最多一个值</li>
</ul>
<h5 id="创建map集合的对象">创建Map集合的对象</h5>
<ul>
<li>多态的方式</li>
<li>具体的实现类HashMap</li>
</ul>
<h5 id="map集合的基本功能">Map集合的基本功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V put(K key, V value)</td>
<td style="text-align:center">添加元素</td>
</tr>
<tr>
<td style="text-align:center">V remove(Object key)</td>
<td style="text-align:center">根据键删除键值对元素</td>
</tr>
<tr>
<td style="text-align:center">void clear()</td>
<td style="text-align:center">移除所有的键值对元素</td>
</tr>
<tr>
<td style="text-align:center">boolean containsKey(Object key)</td>
<td style="text-align:center">判断集合是否包含制定的键</td>
</tr>
<tr>
<td style="text-align:center">boolean containsValue(Object value)</td>
<td style="text-align:center">判断集合是否包含指定的值</td>
</tr>
<tr>
<td style="text-align:center">boolean isEmpty()</td>
<td style="text-align:center">判断集合是否为空</td>
</tr>
<tr>
<td style="text-align:center">int size()</td>
<td style="text-align:center">集合的长度，也就是几何中键值对的个数</td>
</tr>
</tbody>
</table>
<h5 id="map集合的获取功能">Map集合的获取功能</h5>
<table>
<thead>
<tr>
<th style="text-align:center">方法名</th>
<th style="text-align:center">说明</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">V get(Object key)</td>
<td style="text-align:center">根据键获取值</td>
</tr>
<tr>
<td style="text-align:center">Set<K> keySet()</td>
<td style="text-align:center">获取所有键的集合</td>
</tr>
<tr>
<td style="text-align:center">Collection<V> values()</td>
<td style="text-align:center">获取所有值的集合</td>
</tr>
<tr>
<td style="text-align:center">Set&lt;Map.Entry&lt;K,V&gt;&gt;entrySet</td>
<td style="text-align:center">获取所有键值对对象的集合</td>
</tr>
</tbody>
</table>
<h5 id="map的遍历">Map的遍历</h5>
<h6 id="方法一">方法一：</h6>
<pre><code class="language-java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

map.put(&quot;张三&quot;, &quot;20岁&quot;);
map.put(&quot;李四&quot;, &quot;30岁&quot;);
map.put(&quot;王五&quot;, &quot;40岁&quot;);
// 获取键
Set&lt;String&gt; keySet = map.keySet();

for(String key : keySet) {
    // 根据键获取值
    String value = map.get(key);
    System.out.println(key + &quot;,&quot; + value);
    /*李四,30岁
            张三,20岁
            王五,40岁*/
}
</code></pre>
<h6 id="方法二">方法二：</h6>
<pre><code class="language-java">Map&lt;String, String&gt; map = new HashMap&lt;&gt;();

map.put(&quot;张三&quot;, &quot;20岁&quot;);
map.put(&quot;李四&quot;, &quot;30岁&quot;);
map.put(&quot;王五&quot;, &quot;40岁&quot;);
// 获取所有键值对
Set&lt;Map.Entry&lt;String, String&gt;&gt; entrySet = map.entrySet();

for (Map.Entry&lt;String, String&gt; me : entrySet) {
    // 获取键
    String key = me.getKey();
    // 获取值
    String value = me.getValue();
    System.out.println(key + &quot;，&quot; + value);
}
</code></pre>
<h5 id="集合嵌套之arraylist嵌套hashmap">集合嵌套之ArrayList嵌套HashMap</h5>
<pre><code class="language-java">// 创建ArrayList集合
ArrayList&lt;HashMap&lt;String, String&gt;&gt; array = new ArrayList&lt;&gt;();
// 创建HashMap集合
HashMap&lt;String, String&gt; hm1 = new HashMap&lt;&gt;();
// 将键值对添加到HashMap
hm1.put(&quot;张三&quot;, &quot;20&quot;);
// 将HashMap添加到ArrayList集合
array.add(hm1);

HashMap&lt;String, String&gt; hm2 = new HashMap&lt;&gt;();
hm2.put(&quot;李四&quot;, &quot;30&quot;);
array.add(hm2);

HashMap&lt;String, String&gt; hm3 = new HashMap&lt;&gt;();
hm3.put(&quot;王五&quot;, &quot;40&quot;);
array.add(hm3);

// 遍历ArrayList集合
for (HashMap&lt;String, String&gt; hm : array) {
    // 获取HashMap的键
    Set&lt;String&gt; keySet = hm.keySet();
    for (String key : keySet) {
        // 根据键获取值
        String value = hm.get(key);
        // 循环输出
        System.out.println(key + &quot;---&quot; + value);
    }
}
</code></pre>
<h4 id="collections">Collections</h4>
<h5 id="collections类的概述">Collections类的概述</h5>
<ul>
<li>是针对集合操作的工具类</li>
</ul>
<h5 id="collections类的常用方法">Collections类的常用方法</h5>
<ul>
<li><code>public static &lt;T ectends Comparable&lt;? super T&gt;&gt; void sort(List&lt;T&gt; list)</code>：将制定的列表按升序排序</li>
<li><code>public static void reverse(List&lt;?&gt; list)</code>：反转指定列表中元素的顺序</li>
<li><code>public static void shuffle(List&lt;?&gt; list)</code>：使用默认的随机源随机排列指定的列表</li>
</ul>
<pre><code class="language-java">List&lt;Integer&gt; list = new ArrayList&lt;&gt;();

list.add(10);
list.add(50);
list.add(40);
list.add(20);

// Collections.sort(list);    // 排序
// Collections.reverse(list); // 反转
// Collections.shuffle(list); // 随机置换

System.out.println(list);
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[多态]]></title>
        <id>https://HealerLu.github.io/post/8rKXVY6sg/</id>
        <link href="https://HealerLu.github.io/post/8rKXVY6sg/">
        </link>
        <updated>2020-08-28T08:41:43.000Z</updated>
        <content type="html"><![CDATA[<h4 id="多态概述">多态概述</h4>
<blockquote>
<p>同一个对象，在不同时刻表现出来的不同形态。</p>
</blockquote>
<h5 id="多态的前提和体现">多态的前提和体现</h5>
<ul>
<li>
<p>有继承/实现关系</p>
</li>
<li>
<p>有方法重写</p>
</li>
<li>
<p>有父类引用指向子类对象</p>
</li>
<li>
<p>多态中成员访问特点</p>
<ul>
<li>成员变量：编译看左边，执行看左边</li>
<li>成员方法：编译看左边，执行看右边</li>
</ul>
<blockquote>
<p>因为成员方法有重写，而成员变量没有，所以成员变量和成员方法的访问不一样</p>
</blockquote>
</li>
</ul>
<h5 id="多态的好处和弊端">多态的好处和弊端</h5>
<ul>
<li>
<p>多态的好处：提高了程序的扩展性</p>
<blockquote>
<p>具体体现：定义方法的时候，使用父类型作为参数，将来在使用的时候，使用具体的子类型参与操作</p>
</blockquote>
</li>
<li>
<p>多态的弊端：不能使用子类的特有功能</p>
</li>
</ul>
<h5 id="多态中的转型">多态中的转型</h5>
<ul>
<li>
<p>向上转型</p>
<ul>
<li>
<p>从子到父</p>
<blockquote>
<p>父类引用指向子类对象</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>向下转型</p>
<ul>
<li>
<p>从父到子</p>
<blockquote>
<p>父类引用转为子类对象</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="抽象类">抽象类</h4>
<ul>
<li>
<p>概述</p>
<blockquote>
<p>在Java中，一个没有方法体的方法应该定义为抽象方法，而类中如果有抽象方法，该类必须定义为抽象类。</p>
</blockquote>
</li>
<li>
<p>抽象类的特点</p>
<ul>
<li>抽象类和抽象方法必须使用abstract关键字修饰</li>
<li>抽象类中不一定有抽象方法，有抽象方法的类一定是抽象类</li>
<li>抽象类不能实例化。但是抽象类可以参照多态的方法，通过子类对象实例化，这叫抽象类多态。</li>
<li>抽象类的子类
<ul>
<li>要么重写抽象类中的所有抽象方法</li>
<li>要么是抽象类</li>
</ul>
</li>
</ul>
</li>
<li>
<p>抽象类的成员特点</p>
<ul>
<li>成员变量
<ul>
<li>可以是常量，也可以是变量</li>
</ul>
</li>
<li>构造方法
<ul>
<li>有构造方法但是不能实例化。是用于子类访问父类数据的初始化。</li>
</ul>
</li>
<li>成员方法
<ul>
<li>可以有抽象方法：限定子类必须完成某些动作</li>
<li>也可以有非抽象方法：提高代码的复用性</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="接口">接口</h4>
<ul>
<li>
<p>概述</p>
<blockquote>
<p>接口就是一种公共的规范标准，只要付个规范标准。大家都可以通用。Java中的接口更多的体现在对行为的抽象</p>
</blockquote>
</li>
<li>
<p>接口的成员特点</p>
<ul>
<li>成员变量只能是常量，默认修饰符： <code>public static final</code></li>
<li>接口中没有构造方法，因为接口主要是对行为进行抽象，是没有具体存在的。一个类中如果没有父类，默认继承自Object类</li>
</ul>
</li>
<li>
<p>成员方法</p>
<ul>
<li>只能是抽象方法，默认修饰符<code>public abstract</code></li>
</ul>
</li>
<li>
<p>类和类的关系</p>
<ul>
<li>类和类的关系是继承关系，只能单继承，但是可以多继承</li>
</ul>
</li>
<li>
<p>类和接口的关系</p>
<ul>
<li>类和接口是实现关系，可以单实现，也可以多实现。还可以在继承一个类的同时实现多个接口</li>
</ul>
</li>
<li>
<p>接口和接口的关系</p>
<ul>
<li>接口和接口是继承关系，可以单继承也可以多继承</li>
</ul>
</li>
<li>
<p>抽象类和接口的区别</p>
<ul>
<li>
<p>成员区别</p>
<ul>
<li>抽象类：变量、常量；有构造方法，有抽象方法，也有非抽象方法</li>
<li>接口：常量；抽象方法</li>
</ul>
</li>
<li>
<p>关系区别</p>
<ul>
<li>类与类：继承，单继承</li>
<li>类与接口： 实现，可以单实现，也可以多实现</li>
<li>接口与接口：继承，单继承，也可以多继承</li>
</ul>
</li>
<li>
<p>设计理念区别</p>
<ul>
<li>抽象类： 对类抽象，包括属性行为</li>
<li>接口：对行为抽象，主要是行为</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[继承]]></title>
        <id>https://HealerLu.github.io/post/0RqKWGXkz/</id>
        <link href="https://HealerLu.github.io/post/0RqKWGXkz/">
        </link>
        <updated>2020-08-27T09:40:09.000Z</updated>
        <content type="html"><![CDATA[<h4 id="继承概述">继承概述</h4>
<ul>
<li>
<p>概述</p>
<ul>
<li>继承是面向对象的三大特征之一，可以使得子类具有父类的属性和方法，还可以在子类中重新定义，追加属性和方法。</li>
</ul>
</li>
<li>
<p>格式</p>
<ul>
<li><code>public class 子类名 extends 父类名 {}</code></li>
</ul>
</li>
<li>
<p>继承中子类的特点</p>
<ul>
<li>子类可以有父类的内容</li>
<li>子类还可以有自己特有的内容</li>
</ul>
</li>
<li>
<p>继承的好处</p>
<ul>
<li>提高了代码的复用性（多个类相同的成员可以放到同一个类中）</li>
<li>提高了代码的维护性（如果方法的代码需要修改，修改一处即可）</li>
</ul>
</li>
<li>
<p>继承的弊端</p>
<ul>
<li>继承让类与类之间产生了关系，类的耦合性增强了，当父类发生变化时子类实现也不得不跟着变化，削弱了子类的独立性</li>
</ul>
</li>
<li>
<p>super关键字</p>
<ul>
<li>
<p>super关键字的用法和this关键字的用法相似，this代表本类对象的引用</p>
</li>
<li>
<p>super代表父类存储空间的标识（也可以理解为是父类空间的引用）</p>
<table>
<thead>
<tr>
<th style="text-align:center">关键字</th>
<th style="text-align:center">访问成员变量</th>
<th style="text-align:center">访问构造方法</th>
<th style="text-align:center">访问成员方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">this</td>
<td style="text-align:center">this.成员变量<br />访问本类成员变量</td>
<td style="text-align:center">this(...)<br />访问本类构造方法</td>
<td style="text-align:center">this.成员方法(...)<br />访问本类成员方法</td>
</tr>
<tr>
<td style="text-align:center">super</td>
<td style="text-align:center">super.成员变量<br />访问父类成员变量</td>
<td style="text-align:center">super(...)<br />访问父类构造方法</td>
<td style="text-align:center">super.成员方法(...)<br />访问父类成员方法</td>
</tr>
</tbody>
</table>
</li>
</ul>
</li>
<li>
<p>继承中构造方法的访问特点</p>
<ul>
<li>子类中所有的构造方法默认都会访问父类中无参的构造方法
<ul>
<li>因为子类汇集成父类中的数据，可能还会使用父类的数据，所以子类初始化之前，一定要先完成父类数据的初始化</li>
<li>每一个子类构造方法的第一条语句默认都是：<strong>super()</strong></li>
</ul>
</li>
<li>如果父类中没有无参构造方法，只有代餐构造方法，报错的解决方案
<ul>
<li>通过使用<strong>super</strong>关键字去显式的调用父类的带参构造方法</li>
<li>在父类中自己提供一个无参构造方法</li>
</ul>
</li>
</ul>
</li>
<li>
<p>继承中成员方法的访问特点</p>
<ul>
<li>通过子类对象访问一个方法
<ul>
<li>首先会在子类的成员范围内找</li>
<li>其次在父类的成员范围内找</li>
<li>如果都没有就报错（不考虑父亲的父亲）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="方法重写">方法重写</h4>
<ul>
<li>概述
<ul>
<li>子类中出现了和父类中一模一样的方法声明</li>
</ul>
</li>
<li>方法重写的应用
<ul>
<li>当子类需要父类的功能，而功能主体子类有自己特有内用时，可以重写父类中的方法。这样即沿袭了父类的功能，又定义了子类特有的内容。</li>
</ul>
</li>
<li>方法重写的注意事项
<ul>
<li>私有方法不能被重写（父类私有成员子类是不能够继承的）</li>
<li>子类方法访问权限不能更低（public &gt; 默认 &gt; 私有）</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[修饰符]]></title>
        <id>https://HealerLu.github.io/post/Ds88JizU3/</id>
        <link href="https://HealerLu.github.io/post/Ds88JizU3/">
        </link>
        <updated>2020-08-27T09:38:57.000Z</updated>
        <content type="html"><![CDATA[<h4 id="修饰符的分类">修饰符的分类</h4>
<ul>
<li>
<p>权限修饰符</p>
</li>
<li>
<p>状态修饰符</p>
<h5 id="权限修饰符">权限修饰符</h5>
<table>
<thead>
<tr>
<th style="text-align:center">修饰符</th>
<th style="text-align:center">同一个类中</th>
<th style="text-align:center">同一个包中子类无关类</th>
<th style="text-align:center">不同包的子类</th>
<th style="text-align:center">不同包的无关类</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">private</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
<td style="text-align:center">✘</td>
<td style="text-align:center">✘</td>
</tr>
<tr>
<td style="text-align:center">默认</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
<td style="text-align:center">✘</td>
</tr>
<tr>
<td style="text-align:center">protected</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
</tr>
<tr>
<td style="text-align:center">public</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
</tr>
</tbody>
</table>
<h5 id="状态修饰符">状态修饰符</h5>
<ul>
<li>final （最终态）</li>
<li>static（静态）</li>
</ul>
<h6 id="final">final</h6>
<ul>
<li>
<p>final关键字是最终的意思，可以修饰成员方法、成员变量、类</p>
</li>
<li>
<p>final修饰的特点</p>
<ul>
<li>修饰方法：表明该方法是最终方法，不能被重写</li>
<li>修饰变量：表明该变量是常量，不能被再次赋值</li>
<li>修饰类：表明该类是最终类，不能被继承</li>
</ul>
</li>
</ul>
<h6 id="static">static</h6>
<ul>
<li>
<p>static关键字是静态的意思，可以修饰成员方法、成员变量</p>
</li>
<li>
<p>static修饰的特点</p>
<ul>
<li>被类的所有对象共享（这也判断是否使用静态修饰符的条件）</li>
<li>可以通过类名调用（也可以通过对象名调用）</li>
</ul>
</li>
<li>
<p>static访问特点</p>
<table>
<thead>
<tr>
<th style="text-align:center"></th>
<th style="text-align:center">静态成员变量</th>
<th style="text-align:center">非静态成员变量</th>
<th style="text-align:center">静态成员方法</th>
<th style="text-align:center">非静态成员方法</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">非静态成员方法</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✔</td>
</tr>
<tr>
<td style="text-align:center">静态成员方法</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
<td style="text-align:center">✔</td>
<td style="text-align:center">✘</td>
</tr>
</tbody>
</table>
<blockquote>
<p>静态成员方法只能访问静态成员</p>
</blockquote>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[面向对象基础]]></title>
        <id>https://HealerLu.github.io/post/rBwY8CzIg/</id>
        <link href="https://HealerLu.github.io/post/rBwY8CzIg/">
        </link>
        <updated>2020-08-24T03:30:53.000Z</updated>
        <content type="html"><![CDATA[<h4 id="类">类</h4>
<blockquote>
<p>类是对现实生活中一类具有共同属性和行为的事物的抽象</p>
</blockquote>
<ul>
<li>类的特点
<ul>
<li>类是对象的数据类型</li>
<li>类是具有相同属性和行为的一组对象的合集</li>
</ul>
</li>
</ul>
<h4 id="对象的属性">对象的属性</h4>
<blockquote>
<p>对象具有各种特征，每个对象的每个属性都有特定的值</p>
</blockquote>
<h4 id="对象的行为">对象的行为</h4>
<blockquote>
<p>对象能够执行的操作</p>
</blockquote>
<h4 id="类和对象的关系">类和对象的关系</h4>
<blockquote>
<p>类：是对现实生活中一类具有共同属性和行为的事物的抽象</p>
<p>对象：是能够看得到摸得着的真实存在的实体</p>
</blockquote>
<h4 id="类的定义">类的定义</h4>
<ul>
<li>
<p>类的重要性</p>
<blockquote>
<p>类是Java程序的基本组成单位</p>
</blockquote>
</li>
<li>
<p>类的组成</p>
<ul>
<li>
<p>属性</p>
<blockquote>
<p>在类中通过成员变量来体现（类中方法外的变量）</p>
</blockquote>
</li>
<li>
<p>行为</p>
<blockquote>
<p>在类中通过成员方法来体现（和前面的方法相比去掉static关键字即可）</p>
</blockquote>
</li>
</ul>
</li>
</ul>
<h4 id="类的定义-2">类的定义</h4>
<figure data-type="image" tabindex="1"><img src="D:%5CSoftware%5CGridea%5Cdoc%5Cpost-images%5Cimage-20200821141416277.png" alt="类的定义" loading="lazy"></figure>
<h4 id="对象的使用">对象的使用</h4>
<figure data-type="image" tabindex="2"><img src="D:%5CSoftware%5CGridea%5Cdoc%5Cpost-images%5Cimage-20200821141923920.png" alt="对象的创建和使用" loading="lazy"></figure>
<h4 id="成员变量和局部变量的的区别">成员变量和局部变量的的区别</h4>
<table>
<thead>
<tr>
<th style="text-align:center">区别</th>
<th style="text-align:center">成员变量</th>
<th style="text-align:center">局部变量</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">类中位置不同</td>
<td style="text-align:center">类中方法外</td>
<td style="text-align:center">方法内或者方法声明上（形参）</td>
</tr>
<tr>
<td style="text-align:center">内存中位置不同</td>
<td style="text-align:center">堆内存</td>
<td style="text-align:center">栈内存</td>
</tr>
<tr>
<td style="text-align:center">生命周期不同</td>
<td style="text-align:center">随着对象的存在而存在，随着对象的消失而消失</td>
<td style="text-align:center">随着方法的调用而存在，随着方法的调用结束而消失</td>
</tr>
<tr>
<td style="text-align:center">初始化值不同</td>
<td style="text-align:center">有默认的初始化值</td>
<td style="text-align:center">没有默认的初始化值，必须先定义赋值，才能使用</td>
</tr>
</tbody>
</table>
<h4 id="private关键字">private关键字</h4>
<ul>
<li>概述
<ul>
<li>是一个权限修饰符</li>
<li>可以修饰成员（成员变量和成员方法）</li>
<li>作用是保护成员不被别的类使用，被private修饰的成员只在本类中才能访问</li>
</ul>
</li>
<li>针对private修饰的成员变量，如果需要被其他类使用，提供相应的操作
<ul>
<li>提供&quot;get变量名（）&quot;方法，用于获取成员变量的值，方法用public修饰</li>
<li>提供&quot;set变量名（参数）&quot;方法，用于设置成员变量的值，方法用public修饰</li>
</ul>
</li>
</ul>
<h4 id="封装">封装</h4>
<ul>
<li>
<p>封装概述</p>
<ul>
<li>封装是面向对象三大特征之一（封装、继承、多态）</li>
<li>封装是面向对象编程语言对客观世界的模拟，客观世界里的成员变量都是隐藏在对象内部的，外界是无法直接操作的。</li>
</ul>
</li>
<li>
<p>封装的原则</p>
<ul>
<li>
<p>将类的某些信息隐藏在类的内部，不允许外部程序直接访问，而是通过该类提供的方法来实现对隐藏信息的操作和访问</p>
<blockquote>
<p>成员变量用private进行修饰，提供对象的getXxx()/setXxx()方法</p>
</blockquote>
</li>
</ul>
</li>
<li>
<p>封装的好处</p>
<ul>
<li>通过方法来控制成员变量的操作，提高了代码的安全性</li>
<li>把代码用方法进行封装，提高了代码的复用性</li>
</ul>
</li>
</ul>
<h4 id="构造方法">构造方法</h4>
<blockquote>
<p>构造方法是一种特殊的方法</p>
<p>作用：创建对象</p>
<p>格式：<code>public class 类名{</code></p>
<p><code>修饰符 类名(参数){}</code></p>
<p><code>}</code></p>
<p>功能：主要是完成对象数据的初始化</p>
</blockquote>
<ul>
<li>
<p>构造方法的注意事项</p>
<ul>
<li>
<p>构造方法的创建</p>
<ul>
<li>如果没有定义的构造方法，系统将给出一个默认的无参构造方法</li>
<li>如果定义了构造方法，系统将不再提供默认的构造方法</li>
</ul>
</li>
<li>
<p>构造方法的重载</p>
<ul>
<li>如果自定义了带参构造方法，还要使用无参数构造方法，就必须再写一个无参数的构造方法</li>
</ul>
</li>
</ul>
</li>
</ul>
]]></content>
    </entry>
</feed>